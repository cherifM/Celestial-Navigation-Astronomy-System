<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Celestial Navigation & Astronomy System</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    
    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    html, body { 
      height: 100%; 
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      overflow: hidden;
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
    
    @keyframes milkyWay {
      0% { opacity: 0.1; }
      50% { opacity: 0.3; }
      100% { opacity: 0.1; }
    }
    
    #app { 
      display: grid; 
      grid-template-columns: 400px 1fr;
      grid-template-rows: 60px 1fr 200px;
      height: 100%;
      background: 
        radial-gradient(ellipse at 20% 50%, rgba(75, 0, 130, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 20%, rgba(25, 25, 112, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse at 40% 80%, rgba(72, 61, 139, 0.1) 0%, transparent 50%),
        linear-gradient(135deg, #0a0a1f 0%, #000008 50%, #0f0a1a 100%);
    }
    
    #app::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(2px 2px at 20px 30px, rgba(255,255,255,0.2), transparent),
        radial-gradient(1px 1px at 40px 70px, rgba(100,120,255,0.15), transparent),
        radial-gradient(1px 1px at 90px 40px, rgba(138,43,226,0.12), transparent),
        radial-gradient(2px 2px at 130px 80px, rgba(255,255,255,0.18), transparent),
        radial-gradient(1px 1px at 160px 30px, rgba(102,126,234,0.15), transparent),
        radial-gradient(2px 2px at 200px 120px, rgba(255,255,255,0.1), transparent);
      background-repeat: repeat;
      background-size: 250px 150px;
      animation: twinkle 6s ease-in-out infinite alternate;
      pointer-events: none;
      z-index: 1;
    }
    
    #app::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(1px 1px at 50px 90px, rgba(100,120,255,0.08), transparent),
        radial-gradient(1px 1px at 120px 50px, rgba(138,43,226,0.06), transparent),
        radial-gradient(2px 2px at 180px 140px, rgba(255,255,255,0.1), transparent),
        radial-gradient(1px 1px at 80px 180px, rgba(102,126,234,0.08), transparent);
      background-repeat: repeat;
      background-size: 300px 200px;
      animation: twinkle 8s ease-in-out infinite alternate-reverse;
      pointer-events: none;
      z-index: 1;
    }
    
    header { 
      grid-column: 1 / -1;
      padding: 15px 25px;
      background: 
        linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%),
        linear-gradient(90deg, rgba(20,20,40,0.8) 0%, rgba(10,10,30,0.85) 100%);
      border-bottom: 1px solid rgba(100,120,255,0.4);
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      gap: 20px;
      backdrop-filter: blur(25px) saturate(180%);
      box-shadow: 
        0 4px 20px rgba(0,0,0,0.5),
        inset 0 1px 0 rgba(255,255,255,0.1);
      position: relative;
    }
    
    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(ellipse at 50% 50%, rgba(100,120,255,0.15) 0%, transparent 70%);
      pointer-events: none;
    }
    
    header h1 { 
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(135deg, #667eea 0%, #f093fb 50%, #f5576c 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 40px rgba(102,126,234,0.5);
    }
    
    header .desc { 
      color: rgba(200,210,255,0.7);
      font-size: 13px;
      letter-spacing: 0.5px;
    }
    
    #sidebar { 
      grid-row: 2 / 3;
      background: 
        linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.03) 100%),
        linear-gradient(180deg, rgba(15,15,30,0.9) 0%, rgba(10,10,25,0.95) 100%);
      border-right: 1px solid rgba(100,120,255,0.3);
      border-left: 1px solid rgba(255,255,255,0.05);
      overflow-y: auto;
      backdrop-filter: blur(20px) saturate(160%);
      scrollbar-width: thin;
      scrollbar-color: rgba(100,120,255,0.4) transparent;
      position: relative;
    }
    
    #sidebar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(ellipse at 30% 20%, rgba(138,43,226,0.1) 0%, transparent 60%),
        radial-gradient(ellipse at 70% 80%, rgba(65,105,225,0.08) 0%, transparent 50%);
      pointer-events: none;
    }
    
    #sidebar::-webkit-scrollbar {
      width: 6px;
    }
    
    #sidebar::-webkit-scrollbar-track {
      background: transparent;
    }
    
    #sidebar::-webkit-scrollbar-thumb {
      background: rgba(100,120,255,0.3);
      border-radius: 3px;
    }
    
    #sidebar section { 
      margin: 12px;
      padding: 16px;
      background: 
        linear-gradient(135deg, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.06) 100%),
        linear-gradient(135deg, rgba(30,30,60,0.5) 0%, rgba(20,20,50,0.7) 100%);
      border-radius: 20px;
      border: 1px solid rgba(100,120,255,0.3);
      border-top: 1px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(15px) saturate(180%);
      box-shadow: 
        0 8px 32px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.1);
      position: relative;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    #sidebar section::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(ellipse at 50% 0%, rgba(100,120,255,0.1) 0%, transparent 50%);
      border-radius: 20px;
      pointer-events: none;
    }
    
    #sidebar section:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 12px 40px rgba(0,0,0,0.5),
        0 0 20px rgba(100,120,255,0.2),
        inset 0 1px 0 rgba(255,255,255,0.15);
      border-color: rgba(100,120,255,0.4);
    }
    
    #sidebar h3 {
      font-size: 12px;
      font-weight: 700;
      margin-bottom: 14px;
      color: #a78bfa;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    #sidebar h3::before {
      content: '◆';
      color: #667eea;
      animation: pulse 2s infinite;
    }
    
    label { 
      display: block;
      font-size: 10px;
      color: rgba(180,190,255,0.8);
      margin: 10px 0 5px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    input, select, button { 
      width: 100%;
      padding: 10px 14px;
      background: 
        linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%),
        linear-gradient(135deg, rgba(20,20,40,0.7) 0%, rgba(15,15,35,0.8) 100%);
      border: 1px solid rgba(100,120,255,0.4);
      border-top: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      font-size: 13px;
      color: #e5e7eb;
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }
    
    input:focus, select:focus {
      outline: none;
      border-color: rgba(102,126,234,0.8);
      box-shadow: 
        0 0 0 3px rgba(102,126,234,0.3), 
        0 0 20px rgba(102,126,234,0.4),
        inset 0 1px 0 rgba(255,255,255,0.2);
      transform: translateY(-1px);
      background: 
        linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.08) 100%),
        linear-gradient(135deg, rgba(20,20,40,0.8) 0%, rgba(15,15,35,0.9) 100%);
    }
    
    button { 
      cursor: pointer;
      background: 
        linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 100%),
        linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: 1px solid rgba(255,255,255,0.2);
      border-bottom: 1px solid rgba(0,0,0,0.2);
      font-weight: 600;
      color: white;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 11px;
      position: relative;
      overflow: hidden;
      box-shadow: 
        0 4px 15px rgba(102,126,234,0.3),
        inset 0 1px 0 rgba(255,255,255,0.2);
    }
    
    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    
    button:hover::before {
      left: 100%;
    }
    
    button:hover { 
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(102,126,234,0.5),
        0 0 20px rgba(102,126,234,0.3),
        inset 0 1px 0 rgba(255,255,255,0.3);
      border-color: rgba(255,255,255,0.4);
    }
    
    button:active { transform: translateY(0); }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    
    .row { 
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .kpi { 
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 11px;
    }
    
    .kpi > div { 
      background: linear-gradient(135deg, rgba(40,40,80,0.4) 0%, rgba(30,30,70,0.4) 100%);
      border: 1px solid rgba(100,120,255,0.25);
      border-radius: 12px;
      padding: 10px;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }
    
    .kpi > div::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #667eea, #f093fb, #667eea);
      border-radius: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: -1;
    }
    
    .kpi > div:hover::before {
      opacity: 0.3;
    }
    
    .kpi > div:hover {
      transform: translateY(-2px) scale(1.02);
      border-color: #667eea;
    }
    
    .kpi-label { 
      font-size: 9px;
      color: rgba(160,170,255,0.7);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .kpi-value {
      font-size: 18px;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, #a78bfa 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    #canvas-container {
      grid-row: 2 / 3;
      grid-column: 2;
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 1fr;
      position: relative;
      transition: all 0.5s ease;
    }
    
    /* View Mode Classes */
    .view-mode-globe #canvas-container {
      grid-template-rows: 1fr;
    }
    
    .view-mode-globe #canvasSky {
      display: none;
    }
    
    .view-mode-sky #canvas-container {
      grid-template-rows: 1fr;
    }
    
    .view-mode-sky #canvas3d {
      display: none;
    }
    
    .view-mode-globe #canvas3d,
    .view-mode-sky #canvasSky {
      border-bottom: none;
    }
    
    .canvas-view {
      position: relative;
      background: 
        radial-gradient(ellipse 200% 100% at center bottom, rgba(75, 0, 130, 0.08) 0%, transparent 60%),
        radial-gradient(ellipse 150% 80% at 80% 20%, rgba(25, 25, 112, 0.05) 0%, transparent 50%),
        radial-gradient(ellipse 120% 60% at 20% 80%, rgba(138, 43, 226, 0.03) 0%, transparent 40%),
        linear-gradient(180deg, #0a0a1f 0%, #000005 50%, #0f0a1a 100%);
      border: 1px solid rgba(100,120,255,0.1);
      overflow: hidden;
    }
    
    .canvas-view::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.02) 45%, rgba(255, 255, 255, 0.05) 50%, rgba(255, 255, 255, 0.02) 55%, transparent 70%),
        radial-gradient(circle at 30% 40%, rgba(255, 255, 255, 0.03) 0%, transparent 25%),
        radial-gradient(circle at 70% 60%, rgba(255, 255, 255, 0.02) 0%, transparent 25%);
      animation: milkyWay 8s ease-in-out infinite alternate;
      pointer-events: none;
      z-index: 1;
    }
    
    #canvas3d {
      border-bottom: 1px solid rgba(100,120,255,0.2);
    }
    
    #controls {
      position: absolute;
      top: 12px;
      left: 12px;
      background: 
        linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 100%),
        linear-gradient(135deg, rgba(20,20,40,0.85) 0%, rgba(15,15,35,0.9) 100%);
      backdrop-filter: blur(25px) saturate(180%);
      padding: 16px;
      border-radius: 18px;
      border: 1px solid rgba(100,120,255,0.4);
      border-top: 1px solid rgba(255,255,255,0.2);
      color: #e5e7eb;
      font-size: 11px;
      box-shadow: 
        0 8px 32px rgba(0,0,0,0.5),
        inset 0 1px 0 rgba(255,255,255,0.15);
      z-index: 10;
      transition: all 0.3s ease;
      max-width: 220px;
    }
    
    #controls:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 12px 40px rgba(0,0,0,0.6),
        0 0 20px rgba(100,120,255,0.2),
        inset 0 1px 0 rgba(255,255,255,0.2);
    }
    
    #controls label {
      display: inline-flex;
      align-items: center;
      margin-right: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    #controls label:hover {
      color: #a78bfa;
    }
    
    #controls input[type="checkbox"] {
      width: auto;
      margin-right: 6px;
      accent-color: #667eea;
    }
    
    #legend {
      position: absolute;
      right: 12px;
      bottom: 12px;
      background: 
        linear-gradient(135deg, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.06) 100%),
        linear-gradient(135deg, rgba(20,20,40,0.9) 0%, rgba(15,15,35,0.95) 100%);
      backdrop-filter: blur(25px) saturate(180%);
      color: rgba(200,210,255,0.95);
      padding: 16px 20px;
      border-radius: 18px;
      border: 1px solid rgba(100,120,255,0.4);
      border-top: 1px solid rgba(255,255,255,0.2);
      font-size: 11px;
      max-width: 340px;
      line-height: 1.7;
      box-shadow: 
        0 8px 32px rgba(0,0,0,0.5),
        inset 0 1px 0 rgba(255,255,255,0.15);
      transition: all 0.3s ease;
    }
    
    #legend:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 12px 40px rgba(0,0,0,0.6),
        0 0 20px rgba(100,120,255,0.15),
        inset 0 1px 0 rgba(255,255,255,0.2);
    }
    
    #legend strong {
      color: #a78bfa;
      display: block;
      margin-bottom: 8px;
      font-size: 12px;
    }
    
    #graphs {
      grid-column: 1 / -1;
      grid-row: 3;
      background: linear-gradient(180deg, rgba(15,15,30,0.95) 0%, rgba(10,10,25,0.95) 100%);
      border-top: 1px solid rgba(100,120,255,0.2);
      padding: 12px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      overflow-x: auto;
    }
    
    .graph-container {
      background: linear-gradient(135deg, rgba(30,30,60,0.6) 0%, rgba(20,20,50,0.6) 100%);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(100,120,255,0.2);
      min-width: 300px;
    }
    
    .graph-title {
      font-size: 11px;
      color: #a78bfa;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
      font-weight: 600;
    }
    
    canvas.graph {
      width: 100%;
      height: 120px;
      border-radius: 8px;
      background: rgba(10,10,20,0.5);
    }
    
    .equation {
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: rgba(100,255,150,0.8);
      background: rgba(0,20,10,0.4);
      padding: 6px 10px;
      border-radius: 6px;
      margin-top: 8px;
      border: 1px solid rgba(100,255,150,0.2);
      overflow-x: auto;
      white-space: nowrap;
    }
    
    .planet-info {
      background: linear-gradient(135deg, rgba(60,30,90,0.3) 0%, rgba(40,20,70,0.3) 100%);
      border: 1px solid rgba(150,100,255,0.3);
      border-radius: 10px;
      padding: 8px;
      margin-top: 8px;
      font-size: 10px;
      max-height: 120px;
      overflow-y: auto;
    }
    
    .constellation-label {
      position: absolute;
      color: rgba(150,160,255,0.6);
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 2px;
      pointer-events: none;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
    }
    
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #a78bfa;
      font-size: 24px;
      z-index: 1000;
      animation: pulse 1s infinite;
    }
    
    /* Enhanced UI Components */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(102,126,234,0.9) 0%, rgba(118,75,162,0.9) 100%);
      color: white;
      padding: 12px 24px;
      border-radius: 30px;
      font-size: 14px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    
    .toast.show {
      opacity: 1;
    }
    
    .speed-control {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(100,120,255,0.3);
    }
    
    .speed-slider {
      width: 100%;
      margin-top: 8px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 1200px) {
      #app {
        grid-template-columns: 300px 1fr;
      }
      
      #controls {
        max-width: 180px;
        font-size: 10px;
      }
    }
    
    @media (max-width: 900px) {
      #app {
        grid-template-columns: 1fr;
        grid-template-rows: 60px 200px 1fr 200px;
      }
      
      #sidebar {
        grid-row: 2;
        grid-column: 1;
        max-height: 200px;
      }
      
      #canvas-container {
        grid-row: 3;
        grid-column: 1;
      }
      
      #graphs {
        grid-template-columns: 1fr;
      }
    }
    
    /* Tooltip styles */
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: rgba(20, 20, 40, 0.95);
      color: #fff;
      text-align: center;
      border-radius: 8px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
      border: 1px solid rgba(100,120,255,0.3);
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    /* Info panel */
    .info-panel {
      position: fixed;
      top: 70px;
      right: 20px;
      width: 300px;
      background: linear-gradient(135deg, rgba(20,20,40,0.95) 0%, rgba(15,15,35,0.95) 100%);
      border: 1px solid rgba(100,120,255,0.3);
      border-radius: 12px;
      padding: 16px;
      color: #e5e7eb;
      font-size: 12px;
      z-index: 100;
      max-height: 70vh;
      overflow-y: auto;
      display: none;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    
    .info-panel.show {
      display: block;
    }
    
    .info-panel h3 {
      color: #a78bfa;
      margin-bottom: 10px;
      font-size: 14px;
    }
    
    .info-panel p {
      margin-bottom: 8px;
      line-height: 1.4;
    }
    
    .close-info {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #a78bfa;
      font-size: 16px;
      cursor: pointer;
      width: auto;
      padding: 0;
    }
    
    .close-info:hover {
      transform: none;
      box-shadow: none;
    }
  </style>
</head>
<body>
<div class="loading" id="loading">Initializing Universe...</div>
<div id="app" style="display: none;">
  <header>
    <h1>🌌 Advanced Celestial Navigation System</h1>
    <div class="desc">Real-time astronomy, navigation, planets, constellations & scientific analysis</div>
  </header>
  
  <aside id="sidebar">
    <section>
      <h3>Observer Location</h3>
      <div class="row">
        <div>
          <label for="lat">Latitude (°)</label>
          <input id="lat" type="number" step="0.0001" value="53.5361" min="-90" max="90" />
        </div>
        <div>
          <label for="lon">Longitude (°)</label>
          <input id="lon" type="number" step="0.0001" value="10.0227" min="-180" max="180" />
        </div>
      </div>
      <div class="row">
        <div>
          <label for="alt">Altitude (m)</label>
          <input id="alt" type="number" step="1" value="10" />
        </div>
        <div>
          <label for="time">Time (UTC)</label>
          <input id="time" type="datetime-local" step="1" />
        </div>
      </div>
      <div class="row" style="margin-top:12px;">
        <button id="btnNow">🕐 Current Time</button>
        <button id="btnGeo">📍 GPS Location</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="btnAnimate">▶ Animate</button>
        <button id="btnPause" disabled>⏸ Pause</button>
      </div>
      <div class="speed-control">
        <label for="animSpeed">Animation Speed</label>
        <input type="range" id="animSpeed" class="speed-slider" min="1" max="3600" value="60" step="1">
        <div style="display: flex; justify-content: space-between; font-size: 9px; color: rgba(180,190,255,0.7);">
          <span>1s</span>
          <span id="speedValue">60s</span>
          <span>1h</span>
        </div>
      </div>
    </section>
    <section>
      <h3>Solar System</h3>
      <div class="kpi">
        <div>
          <div class="kpi-label">☀️ Sun Az/Alt</div>
          <div class="kpi-value" id="sunPos">—</div>
        </div>
        <div>
          <div class="kpi-label">🌙 Moon Az/Alt</div>
          <div class="kpi-value" id="moonPos">—</div>
        </div>
      </div>
      <div id="planetList" class="planet-info"></div>
    </section>
    <section>
      <h3>Time Systems</h3>
      <div class="kpi">
        <div>
          <div class="kpi-label">LST</div>
          <div class="kpi-value" id="lst">—</div>
        </div>
        <div>
          <div class="kpi-label">GMST</div>
          <div class="kpi-value" id="gmst">—</div>
        </div>
        <div>
          <div class="kpi-label">Julian Day</div>
          <div class="kpi-value" id="jd">—</div>
        </div>
        <div>
          <div class="kpi-label">ΔT (TT-UT)</div>
          <div class="kpi-value" id="deltaT">69.2s</div>
        </div>
      </div>
    </section>
    <section>
      <h3>Navigation Stars</h3>
      <div id="navStars" style="font-size: 10px; color: rgba(180,190,255,0.8);"></div>
    </section>
    <section>
      <h3>Tools</h3>
      <button id="btnScreenshot" style="margin-bottom: 8px;">📸 Take Screenshot</button>
      <button id="btnInfo" style="margin-bottom: 8px;">ℹ️ About This App</button>
      <button id="btnReset">🔄 Reset View</button>
    </section>
  </aside>
  
  <div id="canvas-container">
    <div id="canvas3d" class="canvas-view">
      <div id="controls">
        <div id="viewModeSelector" style="margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px solid rgba(100,120,255,0.3);">
          <label style="display: block; margin-bottom: 6px; color: #a78bfa; font-weight: 600;">View Mode:</label>
          <select id="viewMode" style="width: 100%; margin-bottom: 8px;">
            <option value="split">Split Screen</option>
            <option value="globe">3D Celestial Globe</option>
            <option value="sky">Observer's Sky View</option>
          </select>
        </div>
        <label><input type="checkbox" id="showStars" checked> Stars</label>
        <label><input type="checkbox" id="showConst" checked> Constellations</label>
        <label><input type="checkbox" id="showPlanets" checked> Planets</label>
        <label><input type="checkbox" id="showGrid" checked> Grid</label>
        <label><input type="checkbox" id="showLabels" checked> Labels</label>
        <label><input type="checkbox" id="showOrbits" checked> Orbits</label>
      </div>
    </div>
    <div id="canvasSky" class="canvas-view"></div>
  </div>
  
  <div id="graphs">
    <div class="graph-container">
      <div class="graph-title">Solar Altitude (24h)</div>
      <canvas id="graphSolar" class="graph"></canvas>
      <div class="equation">h = arcsin(sin φ sin δ + cos φ cos δ cos H)</div>
    </div>
    <div class="graph-container">
      <div class="graph-title">Analemma</div>
      <canvas id="graphAnalemma" class="graph"></canvas>
      <div class="equation">EoT = 4(L₀ - 0.0057183 - α + ΔΨ cos ε)</div>
    </div>
    <div class="graph-container">
      <div class="graph-title">Planet Positions</div>
      <canvas id="graphPlanets" class="graph"></canvas>
      <div class="equation">M = M₀ + n(t - t₀); E - e sin E = M</div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<div class="info-panel" id="infoPanel">
  <button class="close-info" id="closeInfo">✕</button>
  <h3>Advanced Celestial Navigation System</h3>
  <p>This application provides a comprehensive view of the celestial sphere with real-time calculations for astronomical objects.</p>
  <h4>Features:</h4>
  <ul style="padding-left: 20px; margin-bottom: 10px;">
    <li>Real-time positions of Sun, Moon, and planets</li>
    <li>30+ constellations with artistic boundaries</li>
    <li>Navigation stars with accurate positions</li>
    <li>3D celestial globe and observer's sky view</li>
    <li>Multiple time systems (LST, GMST, Julian Day)</li>
    <li>Solar altitude and analemma visualizations</li>
  </ul>
  <h4>Controls:</h4>
  <ul style="padding-left: 20px;">
    <li>Drag to rotate the view</li>
    <li>Scroll to zoom in/out</li>
    <li>Use checkboxes to toggle display elements</li>
    <li>Switch between view modes using the dropdown</li>
  </ul>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Ultra-Enhanced Celestial Navigation System with Planets & Constellations
(function() {
  'use strict';
  
  // ============ Constants ============
  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;
  const TAU = Math.PI * 2;
  const AU = 149597870.7; // km
  const J2000 = 2451545.0;
  
  // ============ Planetary Orbital Elements (J2000) ============
  const PLANETS = {
    Mercury: { 
      a: 0.387098, e: 0.205630, i: 7.005, Ω: 48.331, ϖ: 77.456, L: 252.251,
      color: 0x888888, size: 0.02, symbol: '☿'
    },
    Venus: { 
      a: 0.723332, e: 0.006772, i: 3.395, Ω: 76.680, ϖ: 131.563, L: 181.979,
      color: 0xffcc66, size: 0.04, symbol: '♀'
    },
    Mars: { 
      a: 1.523679, e: 0.093400, i: 1.850, Ω: 49.558, ϖ: 336.060, L: 355.433,
      color: 0xff6644, size: 0.03, symbol: '♂'
    },
    Jupiter: { 
      a: 5.202887, e: 0.048498, i: 1.303, Ω: 100.464, ϖ: 14.331, L: 34.351,
      color: 0xccaa88, size: 0.08, symbol: '♃'
    },
    Saturn: { 
      a: 9.536676, e: 0.055546, i: 2.489, Ω: 113.666, ϖ: 93.057, L: 50.077,
      color: 0xffffcc, size: 0.07, symbol: '♄'
    },
    Uranus: { 
      a: 19.189165, e: 0.047318, i: 0.773, Ω: 74.006, ϖ: 173.005, L: 314.055,
      color: 0x66ccff, size: 0.05, symbol: '⛢'
    },
    Neptune: { 
      a: 30.069923, e: 0.008859, i: 1.770, Ω: 131.785, ϖ: 48.124, L: 304.349,
      color: 0x4466ff, size: 0.05, symbol: '♆'
    }
  };
  
  // ============ Extended Constellation Data ============
  const CONSTELLATIONS = {
    // Zodiac Constellations
    'Aries': {
      stars: [[31.79,23.46],[35.16,19.29],[28.66,15.20]],
      lines: [[0,1],[1,2]],
      label: { ra: 32, dec: 20 }
    },
    'Taurus': {
      stars: [[68.98,16.51],[84.41,28.61],[81.57,21.14],[79.27,21.47],[80.90,12.49]],
      lines: [[0,1],[0,2],[0,3],[0,4]],
      label: { ra: 72, dec: 18 }
    },
    'Gemini': {
      stars: [[116.33,28.03],[113.65,31.88],[108.12,20.57],[111.76,24.40]],
      lines: [[0,1],[0,2],[1,3]],
      label: { ra: 115, dec: 26 }
    },
    'Cancer': {
      stars: [[130.11,11.86],[131.17,21.47],[127.99,18.15]],
      lines: [[0,1],[1,2],[2,0]],
      label: { ra: 130, dec: 17 }
    },
    'Leo': {
      stars: [[152.09,11.97],[146.46,14.57],[139.32,19.84],[148.19,26.01],[154.99,15.43]],
      lines: [[0,1],[1,2],[2,3],[3,4],[4,0]],
      label: { ra: 148, dec: 18 }
    },
    'Virgo': {
      stars: [[201.30,-11.16],[213.92,19.18],[190.38,-3.40],[195.54,10.96]],
      lines: [[0,2],[2,3],[3,1]],
      label: { ra: 200, dec: 2 }
    },
    'Libra': {
      stars: [[222.72,-16.04],[229.25,-9.38],[235.28,-25.28]],
      lines: [[0,1],[1,2]],
      label: { ra: 228, dec: -16 }
    },
    'Scorpius': {
      stars: [[247.35,-26.43],[241.36,-19.81],[242.00,-22.62],[243.59,-25.59],[245.46,-29.21],[248.97,-37.10],[252.54,-38.05]],
      lines: [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]],
      label: { ra: 245, dec: -28 }
    },
    'Sagittarius': {
      stars: [[276.04,-30.42],[271.45,-21.06],[283.82,-25.42],[290.66,-26.30],[306.41,-40.62]],
      lines: [[0,1],[1,2],[2,3],[1,4]],
      label: { ra: 280, dec: -28 }
    },
    'Capricornus': {
      stars: [[325.02,-12.51],[320.76,-16.66],[322.17,-24.37]],
      lines: [[0,1],[1,2]],
      label: { ra: 322, dec: -18 }
    },
    'Aquarius': {
      stars: [[331.45,-0.32],[322.89,-15.82],[338.96,-7.78],[346.19,-9.50]],
      lines: [[0,1],[0,2],[0,3]],
      label: { ra: 335, dec: -8 }
    },
    'Pisces': {
      stars: [[344.41,-29.62],[2.07,2.76],[23.06,5.49]],
      lines: [[0,1],[1,2]],
      label: { ra: 15, dec: -8 }
    },
    
    // Major Northern Constellations
    'Ursa Major': {
      stars: [[165.93,61.75],[165.46,56.38],[154.27,53.69],[193.51,53.69],[166.97,49.31],[178.46,47.78],[206.89,49.31]],
      lines: [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,1]],
      label: { ra: 175, dec: 55 }
    },
    'Ursa Minor': {
      stars: [[37.95,89.26],[213.32,74.16],[230.18,77.79],[348.19,75.76]],
      lines: [[0,1],[1,2],[2,3]],
      label: { ra: 200, dec: 80 }
    },
    'Cassiopeia': {
      stars: [[14.18,60.72],[17.43,59.15],[28.60,60.63],[40.83,56.54],[49.48,57.82]],
      lines: [[0,1],[1,2],[2,3],[3,4]],
      label: { ra: 30, dec: 58 }
    },
    'Cepheus': {
      stars: [[337.29,58.42],[309.39,77.63],[344.37,64.63],[20.29,62.20]],
      lines: [[0,1],[1,2],[2,3],[3,0]],
      label: { ra: 340, dec: 65 }
    },
    'Draco': {
      stars: [[159.00,58.97],[173.68,65.71],[212.10,69.33],[269.15,51.49],[279.23,65.71]],
      lines: [[0,1],[1,2],[2,3],[3,4]],
      label: { ra: 220, dec: 65 }
    },
    'Cygnus': {
      stars: [[310.36,45.28],[305.56,40.26],[296.24,33.97],[311.55,27.96],[292.68,51.73]],
      lines: [[0,1],[1,2],[2,3],[1,4]],
      label: { ra: 305, dec: 42 }
    },
    'Lyra': {
      stars: [[279.23,38.78],[284.74,32.69],[281.41,39.15]],
      lines: [[0,1],[0,2]],
      label: { ra: 282, dec: 37 }
    },
    'Aquila': {
      stars: [[297.70,8.87],[292.68,13.86],[290.74,6.41]],
      lines: [[0,1],[0,2]],
      label: { ra: 295, dec: 10 }
    },
    'Perseus': {
      stars: [[51.08,49.86],[47.04,40.96],[58.53,35.79]],
      lines: [[0,1],[1,2]],
      label: { ra: 52, dec: 42 }
    },
    'Andromeda': {
      stars: [[2.07,29.09],[14.21,38.50],[23.06,46.46]],
      lines: [[0,1],[1,2]],
      label: { ra: 12, dec: 38 }
    },
    'Pegasus': {
      stars: [[346.19,15.21],[2.07,29.09],[14.21,25.35],[331.45,9.87]],
      lines: [[0,1],[1,2],[2,3],[3,0]],
      label: { ra: 345, dec: 20 }
    },
    'Auriga': {
      stars: [[79.17,45.99],[89.93,37.21],[84.41,28.61]],
      lines: [[0,1],[1,2],[2,0]],
      label: { ra: 84, dec: 37 }
    },
    'Boötes': {
      stars: [[213.92,19.18],[218.02,30.37],[225.49,37.38]],
      lines: [[0,1],[1,2]],
      label: { ra: 218, dec: 30 }
    },
    'Hercules': {
      stars: [[258.66,26.11],[259.28,31.60],[247.55,36.46]],
      lines: [[0,1],[1,2]],
      label: { ra: 255, dec: 32 }
    },
    'Ophiuchus': {
      stars: [[263.73,12.56],[266.60,-3.69],[255.14,-4.69]],
      lines: [[0,1],[1,2]],
      label: { ra: 262, dec: 2 }
    },
    
    // Major Southern Constellations
    'Orion': {
      stars: [[88.79,7.41],[78.63,-8.20],[83.00,-5.09],[84.05,-1.20],[86.94,-9.67],[81.28,6.35],[85.19,-1.94]],
      lines: [[0,3],[3,1],[3,2],[3,5],[2,4],[1,6],[4,6]],
      label: { ra: 84, dec: -2 }
    },
    'Canis Major': {
      stars: [[101.29,-16.72],[107.10,-26.39],[104.66,-28.97]],
      lines: [[0,1],[1,2]],
      label: { ra: 104, dec: -22 }
    },
    'Canis Minor': {
      stars: [[114.83,5.22],[116.33,8.90]],
      lines: [[0,1]],
      label: { ra: 115, dec: 7 }
    },
    'Centaurus': {
      stars: [[219.90,-60.84],[210.96,-36.37],[222.67,-47.29]],
      lines: [[0,1],[1,2]],
      label: { ra: 218, dec: -48 }
    },
    'Crux': {
      stars: [[186.65,-63.10],[191.93,-59.69],[187.79,-57.11],[183.79,-56.77]],
      lines: [[0,2],[1,3],[0,1]],
      label: { ra: 187, dec: -60 }
    },
    'Carina': {
      stars: [[95.99,-52.70],[138.30,-69.72],[159.89,-59.28]],
      lines: [[0,1],[1,2]],
      label: { ra: 135, dec: -60 }
    },
    'Vela': {
      stars: [[140.53,-55.01],[123.09,-43.43]],
      lines: [[0,1]],
      label: { ra: 132, dec: -49 }
    },
    'Puppis': {
      stars: [[120.90,-40.00],[118.16,-24.86]],
      lines: [[0,1]],
      label: { ra: 119, dec: -32 }
    },
    'Hydra': {
      stars: [[141.90,-8.66],[159.69,-13.06],[174.95,-23.17]],
      lines: [[0,1],[1,2]],
      label: { ra: 158, dec: -15 }
    },
    'Eridanus': {
      stars: [[24.43,-57.24],[58.78,-5.09],[84.41,-9.76]],
      lines: [[0,1],[1,2]],
      label: { ra: 55, dec: -24 }
    }
  };
  
  // ============ Famous Stars Database ============
  const FAMOUS_STARS = [
    // Navigation stars (brightest)
    { name: 'Sirius', ra: 101.29, dec: -16.72, mag: -1.46, color: 0xaaccff, category: 'navigation', constellation: 'Canis Major' },
    { name: 'Canopus', ra: 95.99, dec: -52.7, mag: -0.74, color: 0xfff5ee, category: 'navigation', constellation: 'Carina' },
    { name: 'Arcturus', ra: 213.92, dec: 19.18, mag: -0.05, color: 0xffcc66, category: 'navigation', constellation: 'Boötes' },
    { name: 'Vega', ra: 279.23, dec: 38.78, mag: 0.03, color: 0xaaccff, category: 'navigation', constellation: 'Lyra' },
    { name: 'Capella', ra: 79.17, dec: 45.99, mag: 0.08, color: 0xffff99, category: 'navigation', constellation: 'Auriga' },
    { name: 'Rigel', ra: 78.63, dec: -8.2, mag: 0.13, color: 0xaaccff, category: 'navigation', constellation: 'Orion' },
    { name: 'Procyon', ra: 114.83, dec: 5.22, mag: 0.37, color: 0xfffff0, category: 'navigation', constellation: 'Canis Minor' },
    { name: 'Betelgeuse', ra: 88.79, dec: 7.41, mag: 0.42, color: 0xff6633, category: 'navigation', constellation: 'Orion' },
    { name: 'Altair', ra: 297.7, dec: 8.87, mag: 0.77, color: 0xfffff0, category: 'navigation', constellation: 'Aquila' },
    { name: 'Aldebaran', ra: 68.98, dec: 16.51, mag: 0.85, color: 0xffaa33, category: 'navigation', constellation: 'Taurus' },
    { name: 'Spica', ra: 201.3, dec: -11.16, mag: 0.97, color: 0xaaccff, category: 'navigation', constellation: 'Virgo' },
    { name: 'Antares', ra: 247.35, dec: -26.43, mag: 1.04, color: 0xff3333, category: 'navigation', constellation: 'Scorpius' },
    { name: 'Pollux', ra: 116.33, dec: 28.03, mag: 1.14, color: 0xffcc66, category: 'navigation', constellation: 'Gemini' },
    { name: 'Fomalhaut', ra: 344.41, dec: -29.62, mag: 1.16, color: 0xaaccff, category: 'navigation', constellation: 'Piscis Austrinus' },
    { name: 'Deneb', ra: 310.36, dec: 45.28, mag: 1.25, color: 0xaaccff, category: 'navigation', constellation: 'Cygnus' },
    { name: 'Regulus', ra: 152.09, dec: 11.97, mag: 1.35, color: 0xaaccff, category: 'navigation', constellation: 'Leo' },
    { name: 'Polaris', ra: 37.95, dec: 89.26, mag: 1.97, color: 0xffff99, category: 'navigation', constellation: 'Ursa Minor' },
    
    // Additional famous stars
    { name: 'Castor', ra: 113.65, dec: 31.88, mag: 1.57, color: 0xffffff, category: 'famous', constellation: 'Gemini' },
    { name: 'Bellatrix', ra: 81.28, dec: 6.35, mag: 1.64, color: 0xaaccff, constellation: 'Orion' },
    { name: 'Elnath', ra: 84.41, dec: 28.61, mag: 1.68, color: 0xaaccff, constellation: 'Taurus' },
    { name: 'Miaplacidus', ra: 138.30, dec: -69.72, mag: 1.68, color: 0xffffcc, constellation: 'Carina' },
    { name: 'Alnilam', ra: 84.05, dec: -1.20, mag: 1.69, color: 0xaaccff, constellation: 'Orion' },
    { name: 'Dubhe', ra: 165.93, dec: 61.75, mag: 1.79, color: 0xffcc66, category: 'famous', constellation: 'Ursa Major' },
    { name: 'Mirfak', ra: 51.08, dec: 49.86, mag: 1.80, color: 0xffff99, constellation: 'Perseus' },
    { name: 'Wezen', ra: 107.10, dec: -26.39, mag: 1.84, color: 0xffff99, constellation: 'Canis Major' },
    { name: 'Sargas', ra: 264.33, dec: -42.50, mag: 1.87, color: 0xffaa33, constellation: 'Scorpius' },
    { name: 'Alnitak', ra: 85.19, dec: -1.94, mag: 1.88, color: 0xaaccff, constellation: 'Orion' },
    { name: 'Mintaka', ra: 83.00, dec: -0.30, mag: 2.23, color: 0xaaccff, constellation: 'Orion' },
    { name: 'Merak', ra: 165.46, dec: 56.38, mag: 2.37, color: 0xffffff, category: 'famous', constellation: 'Ursa Major' },
    
    // Variable and special stars
    { name: 'Mira', ra: 34.84, dec: -2.98, mag: 3.5, color: 0xff6666, category: 'variable', constellation: 'Cetus' },
    { name: 'Algol', ra: 47.04, dec: 40.96, mag: 2.87, color: 0xaaccff, category: 'variable', constellation: 'Perseus' },
    { name: 'Delta Cephei', ra: 337.29, dec: 58.42, mag: 4.07, color: 0xffff99, category: 'variable', constellation: 'Cepheus' },
    
    // Zodiac constellation stars
    { name: 'Hamal', ra: 31.79, dec: 23.46, mag: 2.00, color: 0xffcc66, constellation: 'Aries' },
    { name: 'Alphard', ra: 141.9, dec: -8.66, mag: 1.98, color: 0xffaa33, constellation: 'Hydra' },
    { name: 'Markab', ra: 346.19, dec: 15.21, mag: 2.49, color: 0xaaccff, constellation: 'Pegasus' },
    { name: 'Diphda', ra: 10.90, dec: -17.99, mag: 2.04, color: 0xffcc66, constellation: 'Cetus' },
    { name: 'Alpheratz', ra: 2.07, dec: 29.09, mag: 2.06, color: 0xaaccff, constellation: 'Andromeda' },
    
    // Southern sky famous stars
    { name: 'Achernar', ra: 24.43, dec: -57.24, mag: 0.46, color: 0xaaccff, constellation: 'Eridanus' },
    { name: 'Acrux', ra: 186.65, dec: -63.10, mag: 0.77, color: 0xaaccff, category: 'famous', constellation: 'Crux' },
    { name: 'Gacrux', ra: 187.79, dec: -57.11, mag: 1.63, color: 0xff6633, constellation: 'Crux' },
    { name: 'Peacock', ra: 306.41, dec: -56.74, mag: 1.94, color: 0xaaccff, constellation: 'Pavo' },
    { name: 'Mimosa', ra: 191.93, dec: -59.69, mag: 1.25, color: 0xaaccff, constellation: 'Crux' }
  ];
  
  // ============ Math Utilities ============
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const norm360 = d => ((d % 360) + 360) % 360;
  const norm180 = d => ((d + 180) % 360 + 360) % 360 - 180;
  
  // ============ Astronomical Calculations ============
  function toJulianDay(date) {
    try {
      const y = date.getUTCFullYear();
      const m = date.getUTCMonth() + 1;
      const d = date.getUTCDate() + (date.getUTCHours() + date.getUTCMinutes()/60 + date.getUTCSeconds()/3600) / 24;
      
      const a = Math.floor((14 - m) / 12);
      const y1 = y + 4800 - a;
      const m1 = m + 12 * a - 3;
      
      return d + Math.floor((153 * m1 + 2) / 5) + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) - 32045;
    } catch (error) {
      console.error("Error calculating Julian Day:", error);
      return J2000; // Return default value on error
    }
  }
  
  function greenwichMeanSiderealTime(jd) {
    try {
      const T = (jd - J2000) / 36525.0;
      let gmst = 280.46061837 + 360.98564736629 * (jd - J2000) + 0.000387933 * T * T - T * T * T / 38710000;
      return norm360(gmst);
    } catch (error) {
      console.error("Error calculating GMST:", error);
      return 0; // Return default value on error
    }
  }
  
  function localSiderealTime(jd, longitude) {
    try {
      return norm360(greenwichMeanSiderealTime(jd) + longitude);
    } catch (error) {
      console.error("Error calculating LST:", error);
      return 0; // Return default value on error
    }
  }
  
  function obliquityOfEcliptic(jd) {
    try {
      const T = (jd - J2000) / 36525.0;
      return 23.439291 - 0.0130042 * T - 0.00000016 * T * T + 0.000000504 * T * T * T;
    } catch (error) {
      console.error("Error calculating obliquity:", error);
      return 23.44; // Return default value on error
    }
  }
  
  // Kepler's equation solver
  function solveKeplerEquation(M, e, tolerance = 1e-6) {
    try {
      let E = M;
      for (let i = 0; i < 100; i++) {
        const dE = (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
        E -= dE;
        if (Math.abs(dE) < tolerance) break;
      }
      return E;
    } catch (error) {
      console.error("Error solving Kepler's equation:", error);
      return M; // Return default value on error
    }
  }
  
  // Calculate planet position
  function planetPosition(planet, jd) {
    try {
      const T = (jd - J2000) / 36525.0;
      const elements = PLANETS[planet];
      
      if (!elements) {
        console.error(`Unknown planet: ${planet}`);
        return { ra: 0, dec: 0, distance: 0, x: 0, y: 0, z: 0 };
      }
      
      // Mean anomaly
      const n = 360 / (elements.a ** 1.5 * 365.25); // mean motion
      const M = norm360(elements.L + n * (jd - J2000)) * DEG2RAD;
      
      // Solve Kepler's equation
      const E = solveKeplerEquation(M, elements.e);
      
      // True anomaly
      const v = 2 * Math.atan2(
        Math.sqrt(1 + elements.e) * Math.sin(E/2),
        Math.sqrt(1 - elements.e) * Math.cos(E/2)
      );
      
      // Heliocentric distance
      const r = elements.a * (1 - elements.e * Math.cos(E));
      
      // Heliocentric coordinates
      const Ω = elements.Ω * DEG2RAD;
      const ω = (elements.ϖ - elements.Ω) * DEG2RAD;
      const i = elements.i * DEG2RAD;
      
      const xh = r * (Math.cos(Ω) * Math.cos(v + ω) - Math.sin(Ω) * Math.sin(v + ω) * Math.cos(i));
      const yh = r * (Math.sin(Ω) * Math.cos(v + ω) + Math.cos(Ω) * Math.sin(v + ω) * Math.cos(i));
      const zh = r * Math.sin(v + ω) * Math.sin(i);
      
      // Convert to ecliptic coordinates
      const eps = obliquityOfEcliptic(jd) * DEG2RAD;
      
      // For simplicity, assuming Earth at origin (needs Earth position for accuracy)
      const lambda = Math.atan2(yh, xh);
      const beta = Math.atan2(zh, Math.sqrt(xh*xh + yh*yh));
      
      // Convert to RA/Dec
      const ra = Math.atan2(Math.sin(lambda) * Math.cos(eps) - Math.tan(beta) * Math.sin(eps), Math.cos(lambda));
      const dec = Math.asin(Math.sin(beta) * Math.cos(eps) + Math.cos(beta) * Math.sin(eps) * Math.sin(lambda));
      
      return { 
        ra: norm360(ra * RAD2DEG), 
        dec: dec * RAD2DEG,
        distance: r,
        x: xh,
        y: yh,
        z: zh
      };
    } catch (error) {
      console.error(`Error calculating position for ${planet}:`, error);
      return { ra: 0, dec: 0, distance: 0, x: 0, y: 0, z: 0 }; // Return default values on error
    }
  }
  
  // Solar position
  function solarPosition(jd) {
    try {
      const T = (jd - J2000) / 36525.0;
      const M = norm360(357.52911 + 35999.05029 * T - 0.0001537 * T * T);
      const L0 = norm360(280.46646 + 36000.76983 * T + 0.0003032 * T * T);
      const C = (1.914602 - 0.004817 * T - 0.000014 * T * T) * Math.sin(M * DEG2RAD)
              + (0.019993 - 0.000101 * T) * Math.sin(2 * M * DEG2RAD)
              + 0.000289 * Math.sin(3 * M * DEG2RAD);
      const lambda = L0 + C;
      const epsilon = obliquityOfEcliptic(jd);
      const lam = lambda * DEG2RAD;
      const eps = epsilon * DEG2RAD;
      const alpha = Math.atan2(Math.cos(eps) * Math.sin(lam), Math.cos(lam)) * RAD2DEG;
      const delta = Math.asin(Math.sin(eps) * Math.sin(lam)) * RAD2DEG;
      return { ra: norm360(alpha), dec: delta };
    } catch (error) {
      console.error("Error calculating solar position:", error);
      return { ra: 0, dec: 0 }; // Return default values on error
    }
  }
  
  // Lunar position
  function lunarPosition(jd) {
    try {
      const T = (jd - J2000) / 36525.0;
      const L = norm360(218.316 + 481267.881 * T);
      const M = norm360(134.963 + 477198.85 * T);
      const F = norm360(93.272 + 483202.018 * T);
      const lambda = L + 6.289 * Math.sin(M * DEG2RAD);
      const beta = 5.128 * Math.sin(F * DEG2RAD);
      const eps = obliquityOfEcliptic(jd) * DEG2RAD;
      const lam = lambda * DEG2RAD;
      const bet = beta * DEG2RAD;
      const ra = Math.atan2(Math.sin(lam) * Math.cos(eps) - Math.tan(bet) * Math.sin(eps), Math.cos(lam));
      const dec = Math.asin(Math.sin(bet) * Math.cos(eps) + Math.cos(bet) * Math.sin(eps) * Math.sin(lam));
      return { ra: norm360(ra * RAD2DEG), dec: dec * RAD2DEG };
    } catch (error) {
      console.error("Error calculating lunar position:", error);
      return { ra: 0, dec: 0 }; // Return default values on error
    }
  }
  
  // Convert RA/Dec to Alt/Az
  function raDecToAltAz(ra, dec, lat, lon, lst) {
    try {
      const ha = (lst - ra) * DEG2RAD;
      const latRad = lat * DEG2RAD;
      const decRad = dec * DEG2RAD;
      const alt = Math.asin(Math.sin(latRad) * Math.sin(decRad) + Math.cos(latRad) * Math.cos(decRad) * Math.cos(ha));
      const az = Math.atan2(Math.sin(ha), Math.cos(ha) * Math.sin(latRad) - Math.tan(decRad) * Math.cos(latRad));
      return {
        altitude: alt * RAD2DEG,
        azimuth: norm360(az * RAD2DEG + 180)
      };
    } catch (error) {
      console.error("Error converting RA/Dec to Alt/Az:", error);
      return { altitude: 0, azimuth: 0 }; // Return default values on error
    }
  }
  
  // ============ UI Helper Functions ============
  function showToast(message, duration = 3000) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.classList.add('show');
    
    setTimeout(() => {
      toast.classList.remove('show');
    }, duration);
  }
  
  // ============ Three.js Scene Setup ============
  const canvas3d = document.getElementById('canvas3d');
  const canvasSky = document.getElementById('canvasSky');
  
  // 3D Globe Scene
  const scene3d = new THREE.Scene();
  const camera3d = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
  camera3d.position.set(0, 3, 6);
  
  // ============ PERFORMANCE-OPTIMIZED RENDERERS ============
  
  // Adaptive quality based on device capabilities
  const deviceCapabilities = {
    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
    isLowEnd: navigator.hardwareConcurrency < 4 || navigator.deviceMemory < 4,
    maxPixelRatio: Math.min(window.devicePixelRatio, 2)
  };
  
  // Adaptive renderer settings for optimal performance
  const renderer3d = new THREE.WebGLRenderer({ 
    antialias: !deviceCapabilities.isLowEnd, 
    alpha: true,
    powerPreference: "high-performance",
    stencil: false // Disable stencil buffer for better performance
  });
  
  renderer3d.setPixelRatio(deviceCapabilities.isMobile ? 1 : deviceCapabilities.maxPixelRatio);
  
  // Performance-optimized shadow settings
  renderer3d.shadowMap.enabled = !deviceCapabilities.isLowEnd;
  renderer3d.shadowMap.type = deviceCapabilities.isLowEnd ? THREE.BasicShadowMap : THREE.PCFSoftShadowMap;
  renderer3d.shadowMap.autoUpdate = false; // Manual shadow updates for better performance
  
  // WebGL performance optimizations
  renderer3d.capabilities.logarithmicDepthBuffer = true;
  renderer3d.sortObjects = true;
  renderer3d.autoClear = false; // Manual clearing for better control
  
  canvas3d.appendChild(renderer3d.domElement);
  
  // Sky View Scene (Observer's perspective)
  const sceneSky = new THREE.Scene();
  const cameraSky = new THREE.PerspectiveCamera(90, 1, 0.1, 1000);
  cameraSky.position.set(0, 0, 0);
  
  // Optimized sky renderer (simpler than 3D view)
  const rendererSky = new THREE.WebGLRenderer({ 
    antialias: deviceCapabilities.isMobile ? false : true,
    alpha: true,
    powerPreference: "default"
  });
  rendererSky.setPixelRatio(deviceCapabilities.isMobile ? 1 : 1.5);
  rendererSky.sortObjects = true;
  canvasSky.appendChild(rendererSky.domElement);
  
  // ============ LEVEL OF DETAIL (LOD) SYSTEM ============
  
  // LOD manager for dynamic quality adjustment
  const lodManager = {
    currentLevel: deviceCapabilities.isLowEnd ? 0 : 2,
    levels: [
      { name: 'Low', starLimit: 1000, geometryDetail: 8, shadowRes: 1024 },
      { name: 'Medium', starLimit: 1500, geometryDetail: 16, shadowRes: 2048 },
      { name: 'High', starLimit: 2000, geometryDetail: 32, shadowRes: 4096 },
      { name: 'Ultra', starLimit: 3000, geometryDetail: 64, shadowRes: 8192 }
    ],
    
    getCurrentSettings() {
      return this.levels[this.currentLevel];
    },
    
    adjustForPerformance(fps) {
      if (fps < 30 && this.currentLevel > 0) {
        this.currentLevel--;
        console.log(`LOD: Reduced to ${this.levels[this.currentLevel].name} quality`);
        return true;
      } else if (fps > 55 && this.currentLevel < this.levels.length - 1) {
        this.currentLevel++;
        console.log(`LOD: Increased to ${this.levels[this.currentLevel].name} quality`);
        return true;
      }
      return false;
    }
  };
  
  // Performance monitoring for dynamic LOD
  let frameCount = 0;
  let lastTime = performance.now();
  let currentFPS = 60;
  
  function updatePerformanceMetrics() {
    frameCount++;
    const now = performance.now();
    
    if (now - lastTime >= 1000) { // Update every second
      currentFPS = Math.round((frameCount * 1000) / (now - lastTime));
      frameCount = 0;
      lastTime = now;
      
      // Adjust LOD based on performance
      if (lodManager.adjustForPerformance(currentFPS)) {
        // LOD changed - could trigger quality adjustments here
        const settings = lodManager.getCurrentSettings();
        
        // Update shadow resolution if needed
        if (renderer3d.shadowMap.enabled) {
          sunLight.shadow.mapSize.setScalar(settings.shadowRes);
          moonLight.shadow.mapSize.setScalar(Math.min(settings.shadowRes, 4096));
          renderer3d.shadowMap.needsUpdate = true;
        }
      }
    }
  }
  
  // Note: Instanced rendering system implemented in star field creation section
  
  // Custom orbit controls
  class OrbitControls {
    constructor(camera, domElement) {
      this.camera = camera;
      this.domElement = domElement;
      this.spherical = new THREE.Spherical(8, Math.PI/3, 0);
      this.target = new THREE.Vector3(0, 0, 0);
      this.isDragging = false;
      this.previousMouse = { x: 0, y: 0 };
      
      this.domElement.addEventListener('mousedown', e => this.onMouseDown(e));
      this.domElement.addEventListener('mousemove', e => this.onMouseMove(e));
      this.domElement.addEventListener('mouseup', () => this.onMouseUp());
      this.domElement.addEventListener('wheel', e => this.onWheel(e));
      
      // Touch events for mobile
      this.domElement.addEventListener('touchstart', e => this.onTouchStart(e));
      this.domElement.addEventListener('touchmove', e => this.onTouchMove(e));
      this.domElement.addEventListener('touchend', () => this.onTouchEnd());
    }
    
    onMouseDown(e) {
      this.isDragging = true;
      this.previousMouse = { x: e.clientX, y: e.clientY };
    }
    
    onMouseMove(e) {
      if (!this.isDragging) return;
      const deltaX = e.clientX - this.previousMouse.x;
      const deltaY = e.clientY - this.previousMouse.y;
      this.spherical.theta -= deltaX * 0.01;
      this.spherical.phi = clamp(this.spherical.phi + deltaY * 0.01, 0.1, Math.PI - 0.1);
      this.previousMouse = { x: e.clientX, y: e.clientY };
      this.update();
    }
    
    onMouseUp() {
      this.isDragging = false;
    }
    
    onWheel(e) {
      e.preventDefault();
      this.spherical.radius = clamp(this.spherical.radius + e.deltaY * 0.01, 2, 50);
      this.update();
    }
    
    onTouchStart(e) {
      if (e.touches.length === 1) {
        this.isDragging = true;
        this.previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
    }
    
    onTouchMove(e) {
      if (!this.isDragging || e.touches.length !== 1) return;
      e.preventDefault();
      const deltaX = e.touches[0].clientX - this.previousMouse.x;
      const deltaY = e.touches[0].clientY - this.previousMouse.y;
      this.spherical.theta -= deltaX * 0.01;
      this.spherical.phi = clamp(this.spherical.phi + deltaY * 0.01, 0.1, Math.PI - 0.1);
      this.previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      this.update();
    }
    
    onTouchEnd() {
      this.isDragging = false;
    }
    
    update() {
      this.camera.position.setFromSpherical(this.spherical);
      this.camera.position.add(this.target);
      this.camera.lookAt(this.target);
    }
    
    reset() {
      this.spherical = new THREE.Spherical(8, Math.PI/3, 0);
      this.update();
    }
  }
  
  const controls3d = new OrbitControls(camera3d, renderer3d.domElement);
  const controlsSky = new OrbitControls(cameraSky, rendererSky.domElement);
  controlsSky.spherical.radius = 0.1;
  
  // ============ PROFESSIONAL ASTRONOMICAL LIGHTING SYSTEM ============
  
  // === AMBIENT ASTRONOMICAL LIGHTING ===
  
  // Deep space ambient (very subtle cosmic microwave background)
  const cosmicAmbient = new THREE.AmbientLight(0x050a15, 0.02);
  scene3d.add(cosmicAmbient);
  
  // Zodiacal light ambient (scattered sunlight in solar system)
  const zodiacalAmbient = new THREE.AmbientLight(0x1a1622, 0.05);
  scene3d.add(zodiacalAmbient);
  
  // === REALISTIC SUN LIGHTING ===
  
  // Primary sunlight - realistic solar spectrum (5778K blackbody)
  const sunLight = new THREE.DirectionalLight(0xfffaee, 3.2);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 8192; // Ultra-high shadow resolution
  sunLight.shadow.mapSize.height = 8192;
  sunLight.shadow.camera.near = 0.1;
  sunLight.shadow.camera.far = 200;
  sunLight.shadow.camera.left = -50;
  sunLight.shadow.camera.right = 50;
  sunLight.shadow.camera.top = 50;
  sunLight.shadow.camera.bottom = -50;
  sunLight.shadow.bias = -0.0001;
  sunLight.shadow.radius = 8; // Soft shadows
  scene3d.add(sunLight);
  
  // Secondary sun light for realistic atmospheric scattering simulation
  const sunScatter = new THREE.DirectionalLight(0x87ceeb, 0.4);
  sunScatter.castShadow = false; // No double shadows
  scene3d.add(sunScatter);
  
  // === REALISTIC MOON LIGHTING ===
  
  // Moonlight with realistic lunar spectrum (reflected sunlight, slightly blue)
  const moonLight = new THREE.DirectionalLight(0xb0c4de, 0.12);
  moonLight.castShadow = true;
  moonLight.shadow.mapSize.width = 4096;
  moonLight.shadow.mapSize.height = 4096;
  moonLight.shadow.camera.near = 0.1;
  moonLight.shadow.camera.far = 200;
  moonLight.shadow.camera.left = -30;
  moonLight.shadow.camera.right = 30;
  moonLight.shadow.camera.top = 30;
  moonLight.shadow.camera.bottom = -30;
  moonLight.shadow.bias = -0.0002;
  moonLight.shadow.radius = 6;
  scene3d.add(moonLight);
  
  // === STARLIGHT AND GALACTIC ILLUMINATION ===
  
  // Bright star contributions (simulates light from bright stars like Sirius, Canopus)
  const starlight1 = new THREE.PointLight(0xaabbff, 0.15, 150);
  starlight1.position.set(100, 50, 0); // Sirius direction
  scene3d.add(starlight1);
  
  const starlight2 = new THREE.PointLight(0xfff5ee, 0.1, 150);
  starlight2.position.set(-80, -40, 60); // Canopus direction
  scene3d.add(starlight2);
  
  // Galactic center glow (from Milky Way center in Sagittarius)
  const galacticGlow = new THREE.PointLight(0xffd700, 0.08, 200);
  galacticGlow.position.set(0, -20, -100); // Approximate Sgr A* direction
  scene3d.add(galacticGlow);
  
  // === EARTH-SPECIFIC LIGHTING ===
  
  // Earthshine reflection (light reflected from Earth illuminating nearby objects)
  const earthshine = new THREE.PointLight(0x4169e1, 0.3, 50);
  earthshine.position.set(0, 0, 0); // At Earth center
  scene3d.add(earthshine);
  
  // Atmospheric rim lighting (high-altitude atmospheric glow)
  const atmosphericRim = new THREE.PointLight(0x87ceeb, 0.2, 30);
  atmosphericRim.position.set(0, 0, 0); // At Earth center, will be updated in animation
  scene3d.add(atmosphericRim);
  
  // === ADVANCED LIGHTING ENHANCEMENTS ===
  
  // Enable physically correct lights for realistic inverse square falloff
  renderer.physicallyCorrectLights = true;
  
  // Enhanced shadow settings
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft realistic shadows
  renderer.shadowMap.autoUpdate = true;
  
  // HDR tone mapping for realistic brightness handling
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.6; // Optimized for space viewing
  
  // Enhanced color space for accurate astronomical colors
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  
  // ============ Earth (Ultra-realistic) ============
  const earthGeometry = new THREE.SphereGeometry(1, 128, 128);
  
  // Create realistic Earth texture with detailed continents
  const earthCanvas = document.createElement('canvas');
  earthCanvas.width = 4096;
  earthCanvas.height = 2048;
  const earthCtx = earthCanvas.getContext('2d');
  
  // Advanced procedural noise functions for realistic Earth generation
  function noise2D(x, y) {
    return Math.sin(x * 0.01) * Math.cos(y * 0.01) * 0.5 + 0.5;
  }
  
  function fbm(x, y, octaves = 6) {
    let value = 0;
    let amplitude = 1;
    let frequency = 0.005;
    let maxValue = 0;
    
    for (let i = 0; i < octaves; i++) {
      value += noise2D(x * frequency, y * frequency) * amplitude;
      maxValue += amplitude;
      amplitude *= 0.5;
      frequency *= 2;
    }
    
    return value / maxValue;
  }
  
  function ridgedNoise(x, y) {
    return 1 - Math.abs(fbm(x, y, 4) * 2 - 1);
  }
  
  function createUltraRealisticEarthTexture(sunLon = 0) {
    try {
      // Clear all canvases
      earthCtx.clearRect(0, 0, 4096, 2048);
      
      // === OCEAN BASE LAYER ===
      const imageData = earthCtx.createImageData(4096, 2048);
      const data = imageData.data;
      
      for (let y = 0; y < 2048; y++) {
        for (let x = 0; x < 4096; x++) {
          const i = (y * 4096 + x) * 4;
          
          // Convert to lat/lon
          const lon = (x / 4096) * 360 - 180;
          const lat = 90 - (y / 2048) * 180;
          
          // Ocean depth using multiple noise layers
          const deepOcean = fbm(x * 2, y * 2, 8);
          const shallowWater = fbm(x * 8, y * 8, 4) * 0.3;
          const oceanDepth = deepOcean + shallowWater;
          
          // Realistic ocean colors based on depth
          let r, g, b;
          if (oceanDepth < 0.3) { // Deep ocean
            r = Math.floor(5 + oceanDepth * 20);
            g = Math.floor(25 + oceanDepth * 40);  
            b = Math.floor(45 + oceanDepth * 60);
          } else if (oceanDepth < 0.6) { // Medium depth
            r = Math.floor(15 + oceanDepth * 30);
            g = Math.floor(45 + oceanDepth * 50);
            b = Math.floor(75 + oceanDepth * 70);
          } else { // Shallow waters
            r = Math.floor(25 + oceanDepth * 40);
            g = Math.floor(65 + oceanDepth * 60);
            b = Math.floor(95 + oceanDepth * 80);
          }
          
          data[i] = r;     // Red
          data[i + 1] = g; // Green
          data[i + 2] = b; // Blue
          data[i + 3] = 255; // Alpha
        }
      }
      
      earthCtx.putImageData(imageData, 0, 0);
      
      // === CONTINENTAL GENERATION ===
      // Generate realistic landmasses using multiple noise functions
      const continentNoise = new ImageData(4096, 2048);
      const continentData = continentNoise.data;
      
      for (let y = 0; y < 2048; y++) {
        for (let x = 0; x < 4096; x++) {
          const i = (y * 4096 + x) * 4;
          
          // Continental shelf noise
          const continentBase = fbm(x * 0.3, y * 0.3, 6);
          const continentDetail = ridgedNoise(x * 2, y * 2) * 0.3;
          const coastalFeatures = fbm(x * 4, y * 4, 3) * 0.2;
          
          const landMask = continentBase + continentDetail + coastalFeatures;
          
          if (landMask > 0.52) { // Land threshold
            // Elevation-based terrain
            const elevation = (landMask - 0.52) * 2;
            const mountainNoise = ridgedNoise(x * 6, y * 6) * elevation;
            const hillNoise = fbm(x * 12, y * 12, 4) * 0.3;
            
            const totalElevation = elevation + mountainNoise + hillNoise;
            
            let r, g, b;
            
            if (totalElevation > 0.8) { // Snow-capped mountains
              r = Math.floor(240 + Math.random() * 15);
              g = Math.floor(245 + Math.random() * 10);
              b = Math.floor(250 + Math.random() * 5);
            } else if (totalElevation > 0.6) { // Rocky mountains
              r = Math.floor(120 + totalElevation * 60);
              g = Math.floor(100 + totalElevation * 50);
              b = Math.floor(90 + totalElevation * 40);
            } else if (totalElevation > 0.4) { // Hills and forests
              const forestVariation = fbm(x * 16, y * 16, 2);
              r = Math.floor(40 + forestVariation * 30);
              g = Math.floor(80 + forestVariation * 40);
              b = Math.floor(30 + forestVariation * 25);
            } else if (totalElevation > 0.2) { // Plains and grasslands
              r = Math.floor(60 + totalElevation * 40);
              g = Math.floor(100 + totalElevation * 50);
              b = Math.floor(40 + totalElevation * 30);
            } else { // Coastal lowlands
              r = Math.floor(80 + totalElevation * 30);
              g = Math.floor(110 + totalElevation * 40);
              b = Math.floor(50 + totalElevation * 35);
            }
            
            // Desert regions (based on latitude and continental position)
            const lat = 90 - (y / 2048) * 180;
            if ((Math.abs(lat) > 15 && Math.abs(lat) < 35) && Math.random() < 0.3) {
              r = Math.floor(200 + Math.random() * 35);
              g = Math.floor(180 + Math.random() * 30);
              b = Math.floor(120 + Math.random() * 25);
            }
            
            continentData[i] = r;
            continentData[i + 1] = g;
            continentData[i + 2] = b;
            continentData[i + 3] = 255;
          } else {
            continentData[i] = 0;
            continentData[i + 1] = 0;
            continentData[i + 2] = 0;
            continentData[i + 3] = 0;
          }
        }
      }
      
      // Blend continents with ocean
      earthCtx.save();
      earthCtx.globalCompositeOperation = 'source-over';
      earthCtx.putImageData(continentNoise, 0, 0);
      earthCtx.restore();
      
      // === ENHANCED DAY/NIGHT TERMINATOR ===
      const terminatorX = ((sunLon + 90) % 360) * (4096 / 360);
      
      // Advanced twilight zones with atmospheric scattering
      earthCtx.save();
      
      // Civil twilight (6° below horizon)
      const civilTwilight = earthCtx.createLinearGradient(terminatorX - 400, 0, terminatorX + 200, 0);
      civilTwilight.addColorStop(0, 'rgba(25, 25, 50, 0.85)');
      civilTwilight.addColorStop(0.3, 'rgba(40, 30, 60, 0.7)');
      civilTwilight.addColorStop(0.6, 'rgba(60, 45, 80, 0.5)');
      civilTwilight.addColorStop(0.8, 'rgba(80, 60, 100, 0.3)');
      civilTwilight.addColorStop(1, 'rgba(100, 80, 120, 0.1)');
      
      earthCtx.globalCompositeOperation = 'multiply';
      earthCtx.fillStyle = civilTwilight;
      
      if (terminatorX > 2048) {
        earthCtx.fillRect(0, 0, terminatorX - 2048, 2048);
        earthCtx.fillRect(terminatorX, 0, 4096 - terminatorX, 2048);
      } else {
        earthCtx.fillRect(terminatorX, 0, 2048, 2048);
      }
      
      earthCtx.restore();
      
      // === CITY LIGHTS ON NIGHT SIDE ===
      earthCtx.save();
      earthCtx.globalCompositeOperation = 'screen';
      
      // Land base color with elevation variations
      const landColors = [
        '#2D4A2B', // Lowlands - dark green
        '#3A5C38', // Plains - medium green  
        '#4A6B47', // Hills - lighter green
        '#5D7A5A', // Mountains - brownish green
        '#6B8268', // High mountains - gray green
        '#7A8F77'  // Peaks - light gray green
      ];
      
      // Function to draw realistic continent with elevation
      function drawContinent(points, elevationMap, desertRegions = []) {
        earthCtx.beginPath();
        earthCtx.moveTo(points[0][0], points[0][1]);
        for (let i = 1; i < points.length; i++) {
          earthCtx.lineTo(points[i][0], points[i][1]);
        }
        earthCtx.closePath();
        
        // Base terrain color
        const baseColor = landColors[Math.floor(Math.random() * 3)];
        earthCtx.fillStyle = baseColor;
        earthCtx.fill();
        
        // Add elevation variations
        elevationMap.forEach(([x, y, elevation, size]) => {
          const colorIndex = Math.min(elevation, landColors.length - 1);
          const elevationGradient = earthCtx.createRadialGradient(x, y, 0, x, y, size);
          elevationGradient.addColorStop(0, landColors[colorIndex]);
          elevationGradient.addColorStop(1, 'rgba(45, 74, 43, 0)');
          earthCtx.fillStyle = elevationGradient;
          earthCtx.beginPath();
          earthCtx.arc(x, y, size, 0, Math.PI * 2);
          earthCtx.fill();
        });
        
        // Add desert regions
        desertRegions.forEach(([x, y, size]) => {
          const desertGradient = earthCtx.createRadialGradient(x, y, 0, x, y, size);
          desertGradient.addColorStop(0, '#D4A574');
          desertGradient.addColorStop(0.5, '#C19A6B');
          desertGradient.addColorStop(1, 'rgba(196, 154, 107, 0)');
          earthCtx.fillStyle = desertGradient;
          earthCtx.beginPath();
          earthCtx.arc(x, y, size, 0, Math.PI * 2);
          earthCtx.fill();
        });
        
        // Outline
        earthCtx.strokeStyle = 'rgba(26, 58, 26, 0.7)';
        earthCtx.lineWidth = 1;
        earthCtx.stroke();
      }
      
      // North America with Rocky Mountains and Great Plains
      drawContinent([
        [280, 180], [350, 160], [420, 170], [480, 190], [530, 210], [580, 280], 
        [570, 350], [540, 420], [500, 460], [450, 480], [400, 470], [350, 440], 
        [300, 400], [270, 350], [260, 280], [270, 220]
      ], [
        [380, 250, 4, 40], // Rocky Mountains
        [420, 280, 3, 35], // Rockies continued
        [460, 320, 2, 30], // Great Plains
        [340, 200, 3, 25], // Canadian Shield
        [500, 200, 2, 20]  // Appalachians
      ], [
        [480, 380, 25] // Southwest desert
      ]);
      
      // South America with Andes
      drawContinent([
        [420, 500], [460, 485], [500, 490], [520, 520], [530, 580], [525, 640], 
        [510, 700], [490, 760], [470, 810], [450, 840], [420, 835], [400, 820], 
        [390, 780], [385, 720], [395, 660], [405, 540]
      ], [
        [430, 600, 5, 30], // Andes - North
        [440, 700, 5, 35], // Andes - Central
        [450, 780, 4, 25], // Andes - South
        [480, 550, 2, 40], // Brazilian Highlands
        [470, 650, 1, 45]  // Amazon Basin
      ], [
        [490, 520, 20] // Patagonia
      ]);
      
      // Europe with Alps and Scandinavian Mountains
      drawContinent([
        [920, 180], [980, 160], [1040, 170], [1080, 200], [1100, 240], 
        [1090, 280], [1060, 310], [1020, 320], [980, 315], [940, 300], [920, 250]
      ], [
        [1000, 280, 4, 20], // Alps
        [960, 180, 3, 25], // Scandinavian Mountains
        [1040, 200, 2, 15] // Carpathians
      ]);
      
      // Asia with Himalayas and Siberian regions
      drawContinent([
        [1100, 140], [1300, 130], [1500, 140], [1650, 160], [1700, 200], 
        [1720, 260], [1700, 320], [1650, 380], [1550, 420], [1400, 450], 
        [1250, 460], [1150, 440], [1100, 400], [1080, 350], [1090, 280], [1110, 200]
      ], [
        [1400, 350, 5, 50], // Himalayas
        [1500, 300, 4, 40], // Hindu Kush
        [1250, 200, 2, 60], // Siberian Highlands
        [1600, 200, 3, 35], // Ural Mountains
        [1550, 380, 3, 30]  // Tibetan Plateau
      ], [
        [1300, 300, 40], // Gobi Desert
        [1200, 380, 30], // Taklamakan Desert
        [1500, 250, 25]  // Central Asian Steppes
      ]);
      
      // Africa with varied terrain
      drawContinent([
        [980, 380], [1050, 360], [1120, 370], [1180, 390], [1220, 430], 
        [1240, 480], [1250, 540], [1240, 600], [1220, 660], [1180, 720], 
        [1140, 780], [1100, 820], [1040, 830], [980, 825], [940, 800], 
        [920, 760], [930, 700], [950, 640], [965, 580], [975, 520], [980, 460]
      ], [
        [1100, 450, 3, 35], // Ethiopian Highlands
        [1050, 700, 2, 40], // East African Rift
        [980, 600, 1, 30],  // Central African Plateau
        [1150, 380, 2, 25]  // Atlas Mountains
      ], [
        [1080, 400, 50], // Sahara Desert
        [1120, 750, 30], // Kalahari Desert
        [1180, 420, 25]  // Arabian Desert
      ]);
      
      // Australia with Outback
      drawContinent([
        [1430, 630], [1520, 620], [1580, 630], [1620, 660], [1630, 700], 
        [1610, 730], [1570, 750], [1520, 760], [1470, 755], [1430, 740], [1420, 700]
      ], [
        [1500, 680, 2, 25], // Great Dividing Range
        [1560, 700, 1, 30]  // Blue Mountains
      ], [
        [1520, 690, 60] // Australian Outback
      ]);
      
      // Antarctica with realistic ice formations
      earthCtx.fillStyle = '#F0F8FF';
      earthCtx.fillRect(0, 900, 2048, 124);
      
      // Add ice shelf details
      for (let i = 0; i < 15; i++) {
        const x = Math.random() * 2048;
        const y = 900 + Math.random() * 100;
        const iceGradient = earthCtx.createRadialGradient(x, y, 0, x, y, 30);
        iceGradient.addColorStop(0, '#FFFFFF');
        iceGradient.addColorStop(1, 'rgba(240, 248, 255, 0)');
        earthCtx.fillStyle = iceGradient;
        earthCtx.beginPath();
        earthCtx.arc(x, y, 30, 0, Math.PI * 2);
        earthCtx.fill();
      }
      
      // Greenland with glacial features
      earthCtx.fillStyle = '#E8F4F8';
      earthCtx.fillRect(580, 80, 100, 140);
      
      // Add glacial texture
      for (let i = 0; i < 8; i++) {
        const x = 580 + Math.random() * 100;
        const y = 80 + Math.random() * 140;
        const glacierGradient = earthCtx.createRadialGradient(x, y, 0, x, y, 15);
        glacierGradient.addColorStop(0, '#F0FFFF');
        glacierGradient.addColorStop(1, 'rgba(232, 244, 248, 0)');
        earthCtx.fillStyle = glacierGradient;
        earthCtx.beginPath();
        earthCtx.arc(x, y, 15, 0, Math.PI * 2);
        earthCtx.fill();
      }
      
      // City lights on night side
      if (terminatorX > 0) {
        earthCtx.fillStyle = '#ffff88';
        earthCtx.globalAlpha = 0.6;
        
        // Major city clusters
        const cities = [
          [400, 350], [450, 300], [500, 320], // Americas
          [1000, 250], [1050, 200], [1100, 180], // Europe
          [1300, 200], [1400, 250], [1500, 300], // Asia
          [1100, 500], [1150, 550] // Africa
        ];
        
        cities.forEach(([x, y]) => {
          if ((x < terminatorX && terminatorX < 1024) || (terminatorX > 1024 && (x < terminatorX - 1024 || x > terminatorX))) {
            earthCtx.beginPath();
            earthCtx.arc(x, y, 3, 0, Math.PI * 2);
            earthCtx.fill();
          }
        });
        
        earthCtx.globalAlpha = 1;
      }
      
      return new THREE.CanvasTexture(earthCanvas);
    } catch (error) {
      console.error("Error creating Earth texture:", error);
      // Return a simple fallback texture
      const fallbackCanvas = document.createElement('canvas');
      fallbackCanvas.width = 512;
      fallbackCanvas.height = 256;
      const fallbackCtx = fallbackCanvas.getContext('2d');
      fallbackCtx.fillStyle = '#2B5F75';
      fallbackCtx.fillRect(0, 0, 512, 256);
      return new THREE.CanvasTexture(fallbackCanvas);
    }
  }
  
  let earthTexture = createUltraRealisticEarthTexture();
  
  // Create enhanced Earth material with PBR
  const earthMaterial = new THREE.MeshStandardMaterial({
    map: earthTexture,
    roughness: 0.8,
    metalness: 0.1,
    bumpMap: earthTexture,
    bumpScale: 0.02,
    envMapIntensity: 0.3
  });
  
  const earth = new THREE.Mesh(earthGeometry, earthMaterial);
  earth.receiveShadow = true;
  earth.castShadow = true;
  scene3d.add(earth);
  
  // Enhanced Multi-layer Atmosphere
  const atmosphereGeometry = new THREE.SphereGeometry(1.02, 128, 128);
  const atmosphereMaterial = new THREE.ShaderMaterial({
    uniforms: {
      sunDirection: { value: new THREE.Vector3(0, 0, 1) },
      time: { value: 0 }
    },
    vertexShader: `
      varying vec3 vNormal;
      varying vec3 vPosition;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPosition = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 sunDirection;
      uniform float time;
      varying vec3 vNormal;
      varying vec3 vPosition;
      
      void main() {
        vec3 normal = normalize(vNormal);
        float sunFacing = max(0.0, dot(normal, sunDirection));
        float rimLight = pow(0.9 - dot(normal, vec3(0, 0, 1.0)), 1.5);
        
        // Atmospheric scattering colors
        vec3 dayColor = vec3(0.4, 0.7, 1.0);
        vec3 sunsetColor = vec3(1.0, 0.5, 0.2);
        vec3 nightColor = vec3(0.1, 0.2, 0.5);
        
        // Blend colors based on sun angle
        vec3 atmosphereColor = mix(nightColor, dayColor, sunFacing);
        atmosphereColor = mix(atmosphereColor, sunsetColor, 
                            smoothstep(0.0, 0.3, sunFacing) * smoothstep(0.7, 0.3, sunFacing));
        
        // Aurora-like effect at poles
        float polarEffect = abs(vPosition.y) > 0.8 ? 
                           sin(time * 2.0 + vPosition.x * 5.0) * 0.3 + 0.7 : 1.0;
        
        float opacity = rimLight * (0.3 + 0.4 * sunFacing) * polarEffect;
        gl_FragColor = vec4(atmosphereColor, opacity);
      }
    `,
    blending: THREE.AdditiveBlending,
    side: THREE.BackSide,
    transparent: true
  });
  const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
  scene3d.add(atmosphere);
  
  // Outer atmospheric glow
  const outerAtmosphereGeometry = new THREE.SphereGeometry(1.05, 64, 64);
  const outerAtmosphereMaterial = new THREE.ShaderMaterial({
    vertexShader: `
      varying vec3 vNormal;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vNormal;
      void main() {
        float intensity = pow(0.5 - dot(vNormal, vec3(0, 0, 1.0)), 3.0);
        gl_FragColor = vec4(0.2, 0.4, 0.8, 1.0) * intensity;
      }
    `,
    blending: THREE.AdditiveBlending,
    side: THREE.BackSide,
    transparent: true
  });
  const outerAtmosphere = new THREE.Mesh(outerAtmosphereGeometry, outerAtmosphereMaterial);
  scene3d.add(outerAtmosphere);
  
  // ============ Celestial Sphere ============
  const celestialSphere = new THREE.Group();
  scene3d.add(celestialSphere);
  
  // Famous stars background field
  const starsGeometry = new THREE.BufferGeometry();
  const starPositions = [];
  const starColors = [];
  const starSizes = [];
  
  // ============ ENHANCED STELLAR POPULATION GENERATION ============
  
  // Realistic stellar density - more stars toward galactic plane
  for (let i = 0; i < 2000; i++) {
    let ra = Math.random() * 360;
    let dec = (Math.random() - 0.5) * 180;
    
    // Create galactic plane concentration (Milky Way effect)
    const galacticLatitude = Math.abs(dec);
    if (galacticLatitude < 30 && Math.random() < 0.7) {
      // Higher density near galactic plane
      dec *= 0.3; // Concentrate stars toward galactic plane
    }
    
    const r = 100;
    const raRad = ra * DEG2RAD;
    const decRad = dec * DEG2RAD;
    
    starPositions.push(
      r * Math.cos(decRad) * Math.cos(raRad),
      r * Math.sin(decRad),
      r * Math.cos(decRad) * Math.sin(raRad)
    );
    
    // Professional magnitude distribution (more faint stars than bright)
    const magnitudeDistribution = Math.random();
    let magnitude;
    if (magnitudeDistribution < 0.05) magnitude = 4.0 + Math.random() * 0.5; // Mag 4-4.5
    else if (magnitudeDistribution < 0.15) magnitude = 4.5 + Math.random() * 0.5; // Mag 4.5-5
    else if (magnitudeDistribution < 0.35) magnitude = 5.0 + Math.random() * 0.5; // Mag 5-5.5
    else if (magnitudeDistribution < 0.60) magnitude = 5.5 + Math.random() * 0.5; // Mag 5.5-6
    else magnitude = 6.0 + Math.random() * 0.5; // Mag 6-6.5 (faintest visible)
    
    // Stellar type distribution (realistic main sequence distribution)
    const stellarTypeRand = Math.random();
    let stellarColor;
    let stellarSize;
    
    if (stellarTypeRand < 0.001) { // 0.1% O-type (very rare)
      stellarColor = new THREE.Color(0x9bb0ff);
      stellarSize = 3.0;
    } else if (stellarTypeRand < 0.01) { // 0.9% B-type (rare)
      stellarColor = new THREE.Color(0xaabfff);  
      stellarSize = 2.5;
    } else if (stellarTypeRand < 0.04) { // 3% A-type
      stellarColor = new THREE.Color(0xcad7ff);
      stellarSize = 2.0;
    } else if (stellarTypeRand < 0.10) { // 6% F-type
      stellarColor = new THREE.Color(0xf8f7ff);
      stellarSize = 1.8;
    } else if (stellarTypeRand < 0.18) { // 8% G-type (like Sun)
      stellarColor = new THREE.Color(0xfff4ea);
      stellarSize = 1.5;
    } else if (stellarTypeRand < 0.30) { // 12% K-type
      stellarColor = new THREE.Color(0xffd2a1);
      stellarSize = 1.2;
    } else { // 70% M-type (most common)
      stellarColor = new THREE.Color(0xffad51);
      stellarSize = 0.8;
    }
    
    // Adjust brightness based on magnitude
    const brightness = Math.max(0.1, 1.0 - magnitude * 0.15);
    
    starColors.push(
      stellarColor.r * brightness, 
      stellarColor.g * brightness, 
      stellarColor.b * brightness
    );
    
    // Size based on magnitude and stellar type
    const baseSize = Math.max(0.3, 2.0 - magnitude * 0.2);
    starSizes.push(baseSize * stellarSize * 0.5);
  }
  
  // Advanced stellar classification colors
  const stellarColors = {
    'O': 0x9bb0ff, // Blue supergiant
    'B': 0xaabfff, // Blue-white giant
    'A': 0xcad8ff, // White
    'F': 0xfff4ea, // Yellow-white
    'G': 0xfff5b4, // Yellow (like Sun)
    'K': 0xffd2a1, // Orange
    'M': 0xffad51  // Red
  };
  
  function getStarColor(star) {
    if (star.color) return star.color;
    
    // Classify by temperature based on magnitude and name
    if (star.name.includes('Rigel') || star.name.includes('Bellatrix')) return stellarColors.B;
    if (star.name.includes('Vega') || star.name.includes('Sirius')) return stellarColors.A;
    if (star.name.includes('Canopus') || star.name.includes('Procyon')) return stellarColors.F;
    if (star.name.includes('Capella') || star.name.includes('Polaris')) return stellarColors.G;
    if (star.name.includes('Arcturus') || star.name.includes('Aldebaran')) return stellarColors.K;
    if (star.name.includes('Betelgeuse') || star.name.includes('Antares')) return stellarColors.M;
    
    return star.color || 0xffffff;
  }
  
  // ============ ADVANCED STELLAR CLASSIFICATION SYSTEM ============
  
  // Enhanced stellar classification with proper B-V color index
  function getAdvancedStarColor(star) {
    // Professional stellar classification colors based on temperature
    const stellarTypes = {
      'O': { temp: 30000, color: 0x9bb0ff }, // Blue-white
      'B': { temp: 20000, color: 0xaabfff }, // Blue-white  
      'A': { temp: 9000, color: 0xcad7ff },  // White
      'F': { temp: 7000, color: 0xf8f7ff },  // Yellow-white
      'G': { temp: 5800, color: 0xfff4ea },  // Yellow (like our Sun)
      'K': { temp: 4900, color: 0xffd2a1 },  // Orange
      'M': { temp: 3500, color: 0xffad51 }   // Red
    };
    
    // Determine stellar type from magnitude and known classifications
    let stellarType = 'G'; // Default to solar type
    if (star.mag < -1) stellarType = 'O';
    else if (star.mag < 0) stellarType = 'B';  
    else if (star.mag < 1) stellarType = 'A';
    else if (star.mag < 2) stellarType = 'F';
    else if (star.mag < 3) stellarType = 'G';
    else if (star.mag < 4) stellarType = 'K';
    else stellarType = 'M';
    
    return stellarTypes[stellarType].color;
  }
  
  // Multi-scale star rendering system
  const famousStarMeshes = [];
  const starInstancedGeometries = new Map();
  
  // Create different geometry types for different star categories
  const createStarGeometry = (size, detail = 8) => {
    return new THREE.SphereGeometry(size, detail, detail);
  };
  
  FAMOUS_STARS.forEach(star => {
    const r = 100;
    const raRad = star.ra * DEG2RAD;
    const decRad = star.dec * DEG2RAD;
    
    const pos = new THREE.Vector3(
      r * Math.cos(decRad) * Math.cos(raRad),
      r * Math.sin(decRad),
      r * Math.cos(decRad) * Math.sin(raRad)
    );
    
    // Professional magnitude-based size calculation  
    const apparentMagnitude = star.mag;
    const starSize = Math.max(0.15, 2.0 * Math.pow(2.512, -apparentMagnitude * 0.4));
    const stellarColor = getAdvancedStarColor(star);
    
    // Create professional star with magnitude-based brightness
    const starGeom = createStarGeometry(starSize, 16);
    const brightness = Math.max(0.3, 2.5 - star.mag * 0.4);
    
    // Multi-layered star system for different magnitudes
    if (star.mag < -1) {
      // Super bright stars (like Sirius) - Multi-layer system
      const coreMat = new THREE.MeshBasicMaterial({
        color: stellarColor,
        transparent: true,
        opacity: 1.0
      });
      const starCore = new THREE.Mesh(starGeom, coreMat);
      
      // Bright halo
      const haloGeom = createStarGeometry(starSize * 2.5, 12);
      const haloMat = new THREE.MeshBasicMaterial({
        color: stellarColor,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
      });
      const starHalo = new THREE.Mesh(haloGeom, haloMat);
      
      // Subtle outer glow
      const glowGeom = createStarGeometry(starSize * 4, 8);
      const glowMat = new THREE.MeshBasicMaterial({
        color: stellarColor,
        transparent: true,
        opacity: 0.15,
        blending: THREE.AdditiveBlending
      });
      const starGlow = new THREE.Mesh(glowGeom, glowMat);
      
      // Diffraction spikes for very bright stars
      const spikeGroup = new THREE.Group();
      for (let i = 0; i < 4; i++) {
        const spikeGeom = new THREE.PlaneGeometry(starSize * 6, starSize * 0.3);
        const spikeMat = new THREE.MeshBasicMaterial({
          color: stellarColor,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
        });
        const spike = new THREE.Mesh(spikeGeom, spikeMat);
        spike.rotation.z = (i * Math.PI) / 2;
        spikeGroup.add(spike);
      }
      
      const starGroup = new THREE.Group();
      starGroup.add(starCore, starHalo, starGlow, spikeGroup);
      starGroup.position.copy(pos);
      starGroup.userData = star;
      celestialSphere.add(starGroup);
      famousStarMeshes.push(starGroup);
      
    } else if (star.mag < 0.5) {
      // Very bright stars - Core + Halo
      const coreMat = new THREE.MeshBasicMaterial({
        color: stellarColor,
        transparent: true,
        opacity: brightness
      });
      const starCore = new THREE.Mesh(starGeom, coreMat);
      
      const haloGeom = createStarGeometry(starSize * 2, 10);
      const haloMat = new THREE.MeshBasicMaterial({
        color: stellarColor,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      const starHalo = new THREE.Mesh(haloGeom, haloMat);
      
      const starGroup = new THREE.Group();
      starGroup.add(starCore, starHalo);
      starGroup.position.copy(pos);
      starGroup.userData = star;
      celestialSphere.add(starGroup);
      famousStarMeshes.push(starGroup);
      
    } else if (star.mag < 2) {
      // Bright stars - Core + subtle glow
      const coreMat = new THREE.MeshBasicMaterial({
        color: stellarColor,
        transparent: true,
        opacity: brightness
      });
      const starCore = new THREE.Mesh(starGeom, coreMat);
      
      const glowGeom = createStarGeometry(starSize * 1.5, 8);
      const glowMat = new THREE.MeshBasicMaterial({
        color: stellarColor,
        transparent: true,
        opacity: 0.2,
        blending: THREE.AdditiveBlending
      });
      const starGlow = new THREE.Mesh(glowGeom, glowMat);
      
      const starGroup = new THREE.Group();
      starGroup.add(starCore, starGlow);
      starGroup.position.copy(pos);
      starGroup.userData = star;
      celestialSphere.add(starGroup);
      famousStarMeshes.push(starGroup);
      
    } else {
      // Standard stars - Simple sphere
      const starMat = new THREE.MeshBasicMaterial({
        color: stellarColor,
        transparent: true,
        opacity: brightness
      });
      const starMesh = new THREE.Mesh(starGeom, starMat);
      starMesh.position.copy(pos);
      starMesh.userData = star;
      celestialSphere.add(starMesh);
      famousStarMeshes.push(starMesh);
    }
    
    // Add simplified version to sky scene
    const skyStarGeom = createStarGeometry(starSize * 0.8, 12);
    const skyStarMat = new THREE.MeshBasicMaterial({ 
      color: stellarColor,
      transparent: true,
      opacity: Math.min(1, brightness * 0.8)
    });
    const skyStarMesh = new THREE.Mesh(skyStarGeom, skyStarMat);
    skyStarMesh.position.copy(pos);
    skyStarMesh.userData = star;
    sceneSky.add(skyStarMesh);
  });
  
  starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
  starsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
  
  // Enhanced points material with professional settings
  const starsMaterial = new THREE.PointsMaterial({
    size: 0.08,
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    sizeAttenuation: true, // Enable realistic distance-based sizing
    blending: THREE.AdditiveBlending,
    alphaTest: 0.1 // Remove very faint pixels for cleaner appearance
  });
  
  const starsPoints = new THREE.Points(starsGeometry, starsMaterial);
  celestialSphere.add(starsPoints);
  
  // Clone for sky view
  const skyStars = starsPoints.clone();
  sceneSky.add(skyStars);
  
  // ============ PROFESSIONAL DEEP SKY & MILKY WAY SYSTEM ============
  const cosmicGroup = new THREE.Group();
  celestialSphere.add(cosmicGroup);
  
  // === ENHANCED MILKY WAY VISUALIZATION ===
  
  // Create realistic Milky Way band using multiple layers
  const milkyWayGroup = new THREE.Group();
  cosmicGroup.add(milkyWayGroup);
  
  // Main galactic plane
  const galacticPlaneGeom = new THREE.RingGeometry(88, 110, 64, 1, 0, Math.PI * 2);
  const galacticPlaneMat = new THREE.MeshBasicMaterial({
    color: 0x4a5568,
    transparent: true,
    opacity: 0.12,
    side: THREE.DoubleSide
  });
  const galacticPlane = new THREE.Mesh(galacticPlaneGeom, galacticPlaneMat);
  galacticPlane.rotation.x = Math.PI / 2;
  galacticPlane.rotation.z = Math.PI / 6; // Tilted for realism
  milkyWayGroup.add(galacticPlane);
  
  // Bright galactic center
  const galacticCenterGeom = new THREE.RingGeometry(92, 106, 32, 1, 0, Math.PI * 2);
  const galacticCenterMat = new THREE.MeshBasicMaterial({
    color: 0xffd700,
    transparent: true,
    opacity: 0.08,
    side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending
  });
  const galacticCenter = new THREE.Mesh(galacticCenterGeom, galacticCenterMat);
  galacticCenter.rotation.x = Math.PI / 2;
  galacticCenter.rotation.z = Math.PI / 6;
  milkyWayGroup.add(galacticCenter);
  
  // Spiral arm structure
  for (let arm = 0; arm < 4; arm++) {
    const armAngle = (arm * Math.PI) / 2;
    const armGroup = new THREE.Group();
    
    // Create spiral arm using multiple segments
    for (let segment = 0; segment < 12; segment++) {
      const segmentAngle = armAngle + (segment * Math.PI) / 24;
      const radius = 95 + segment * 2;
      
      const armGeom = new THREE.RingGeometry(radius - 3, radius + 3, 8, 1, segmentAngle, Math.PI / 12);
      const armMat = new THREE.MeshBasicMaterial({
        color: 0x6fa8dc,
        transparent: true,
        opacity: 0.06 - segment * 0.003, // Fade with distance
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });
      const armSegment = new THREE.Mesh(armGeom, armMat);
      armSegment.rotation.x = Math.PI / 2;
      armGroup.add(armSegment);
    }
    
    milkyWayGroup.add(armGroup);
  }
  
  // === PROFESSIONAL DEEP SKY OBJECTS ===
  
  // Famous nebulae database with real positions
  const NEBULAE = [
    { name: 'Orion Nebula', ra: 84, dec: -5, type: 'emission', color: 0xff6b9d, size: 2.5 },
    { name: 'Eagle Nebula', ra: 274, dec: -14, type: 'emission', color: 0xff4757, size: 1.8 },
    { name: 'Ring Nebula', ra: 283, dec: 33, type: 'planetary', color: 0x3742fa, size: 1.2 },
    { name: 'Crab Nebula', ra: 84, dec: 22, type: 'supernova', color: 0xff6348, size: 1.5 },
    { name: 'Horsehead Nebula', ra: 85, dec: -2, type: 'dark', color: 0x2c3e50, size: 0.8 },
    { name: 'Cat\'s Eye Nebula', ra: 269, dec: 67, type: 'planetary', color: 0x00d2d3, size: 1.0 },
    { name: 'Rosette Nebula', ra: 98, dec: 5, type: 'emission', color: 0xff3838, size: 2.0 },
    { name: 'North America Nebula', ra: 312, dec: 44, type: 'emission', color: 0xff4757, size: 3.0 }
  ];
  
  const nebulaGroup = new THREE.Group();
  cosmicGroup.add(nebulaGroup);
  
  NEBULAE.forEach(nebula => {
    const r = 97;
    const raRad = nebula.ra * DEG2RAD;
    const decRad = nebula.dec * DEG2RAD;
    
    const pos = new THREE.Vector3(
      r * Math.cos(decRad) * Math.cos(raRad),
      r * Math.sin(decRad),
      r * Math.cos(decRad) * Math.sin(raRad)
    );
    
    // Create multi-layer nebula effect
    const nebulaCore = new THREE.Mesh(
      new THREE.SphereGeometry(nebula.size * 0.3, 16, 16),
      new THREE.MeshBasicMaterial({
        color: nebula.color,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
      })
    );
    nebulaCore.position.copy(pos);
    
    const nebulaHalo = new THREE.Mesh(
      new THREE.SphereGeometry(nebula.size, 16, 16),
      new THREE.MeshBasicMaterial({
        color: nebula.color,
        transparent: true,
        opacity: 0.15,
        blending: THREE.AdditiveBlending
      })
    );
    nebulaHalo.position.copy(pos);
    
    const nebulaGlow = new THREE.Mesh(
      new THREE.SphereGeometry(nebula.size * 1.8, 12, 12),
      new THREE.MeshBasicMaterial({
        color: nebula.color,
        transparent: true,
        opacity: 0.05,
        blending: THREE.AdditiveBlending
      })
    );
    nebulaGlow.position.copy(pos);
    
    nebulaGroup.add(nebulaCore, nebulaHalo, nebulaGlow);
    
    // Add to sky view with simpler representation
    const skyNebula = new THREE.Mesh(
      new THREE.SphereGeometry(nebula.size * 0.5, 12, 12),
      new THREE.MeshBasicMaterial({
        color: nebula.color,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      })
    );
    skyNebula.position.copy(pos);
    sceneSky.add(skyNebula);
  });
  
  // === STAR CLUSTERS ===
  
  // Famous star clusters
  const STAR_CLUSTERS = [
    { name: 'Pleiades', ra: 56, dec: 24, type: 'open', stars: 15 },
    { name: 'Hyades', ra: 67, dec: 16, type: 'open', stars: 12 },
    { name: 'Beehive', ra: 130, dec: 20, type: 'open', stars: 18 },
    { name: 'Globular M13', ra: 250, dec: 36, type: 'globular', stars: 25 },
    { name: 'Omega Centauri', ra: 201, dec: -47, type: 'globular', stars: 30 }
  ];
  
  const clusterGroup = new THREE.Group();
  cosmicGroup.add(clusterGroup);
  
  STAR_CLUSTERS.forEach(cluster => {
    const r = 98;
    const raRad = cluster.ra * DEG2RAD;
    const decRad = cluster.dec * DEG2RAD;
    
    const centerPos = new THREE.Vector3(
      r * Math.cos(decRad) * Math.cos(raRad),
      r * Math.sin(decRad),
      r * Math.cos(decRad) * Math.sin(raRad)
    );
    
    // Create cluster stars
    const clusterStars = new THREE.Group();
    const clusterRadius = cluster.type === 'globular' ? 1.5 : 2.5;
    
    for (let i = 0; i < cluster.stars; i++) {
      const angle1 = Math.random() * Math.PI * 2;
      const angle2 = Math.random() * Math.PI;
      const distance = Math.random() * clusterRadius;
      
      const starPos = new THREE.Vector3(
        centerPos.x + distance * Math.sin(angle2) * Math.cos(angle1),
        centerPos.y + distance * Math.cos(angle2),
        centerPos.z + distance * Math.sin(angle2) * Math.sin(angle1)
      );
      
      const starSize = cluster.type === 'globular' ? 0.1 + Math.random() * 0.1 : 0.15 + Math.random() * 0.2;
      const starColor = cluster.type === 'globular' ? 0xffd700 : 0xaabbff;
      
      const clusterStar = new THREE.Mesh(
        new THREE.SphereGeometry(starSize, 8, 8),
        new THREE.MeshBasicMaterial({
          color: starColor,
          transparent: true,
          opacity: 0.7
        })
      );
      clusterStar.position.copy(starPos);
      clusterStars.add(clusterStar);
    }
    
    clusterGroup.add(clusterStars);
  });
  
  // === ZODIACAL LIGHT ===
  
  const zodiacalGeom = new THREE.ConeGeometry(25, 50, 32, 1, true);
  const zodiacalMat = new THREE.MeshBasicMaterial({
    color: 0xffd700,
    transparent: true,
    opacity: 0.03,
    side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending
  });
  const zodiacalLight = new THREE.Mesh(zodiacalGeom, zodiacalMat);
  zodiacalLight.rotation.x = -Math.PI / 2;
  cosmicGroup.add(zodiacalLight);
  
  // Old nebulae code removed - replaced with enhanced system above
  
  // Nebulae rendering moved to enhanced system above with multi-layer effects
    
    const nebulaGeometry = new THREE.SphereGeometry(nebula.size, 32, 32);
    const nebulaMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        nebulaColor: { value: new THREE.Vector3(...nebula.color) },
        intensity: { value: 0.3 }
      },
      vertexShader: `
        uniform float time;
        varying vec3 vPosition;
        varying vec3 vNormal;
        void main() {
          vPosition = position;
          vNormal = normal;
          
          // Add slight movement to simulate gas flow
          vec3 pos = position;
          pos += sin(time * 0.3 + position.x * 0.5) * normal * 0.1;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 nebulaColor;
        uniform float intensity;
        varying vec3 vPosition;
        varying vec3 vNormal;
        
        // Fractal noise for realistic nebula texture
        float noise(vec3 p) {
          return fract(sin(dot(p, vec3(127.1, 311.7, 543.5))) * 43758.5453);
        }
        
        float fractalNoise(vec3 p) {
          float f = 0.0;
          f += 0.5000 * noise(p); p *= 2.0;
          f += 0.2500 * noise(p); p *= 2.0;
          f += 0.1250 * noise(p); p *= 2.0;
          f += 0.0625 * noise(p);
          return f;
        }
        
        void main() {
          vec3 pos = vPosition;
          
          // Create wispy nebula structure
          float density = fractalNoise(pos * 0.5 + time * 0.1);
          density *= fractalNoise(pos * 0.8 - time * 0.05);
          
          // Add distance falloff
          float dist = length(pos);
          float falloff = 1.0 - smoothstep(0.0, 2.0, dist);
          
          // Color variations within the nebula
          vec3 color1 = nebulaColor;
          vec3 color2 = nebulaColor * vec3(0.5, 1.2, 0.8);
          vec3 finalColor = mix(color1, color2, sin(time * 0.5 + pos.x) * 0.5 + 0.5);
          
          // Brightness pulsing
          float pulse = sin(time * 2.0 + pos.y) * 0.3 + 0.7;
          
          float alpha = density * falloff * intensity * pulse;
          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide
    });
    
    const nebulaMesh = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
    nebulaMesh.position.copy(pos);
    cosmicGroup.add(nebulaMesh);
  });
  
  // Add cosmic dust clouds and star-forming regions
  for (let i = 0; i < 40; i++) {
    const cloudSize = Math.random() * 3 + 1;
    const cloudGeometry = new THREE.SphereGeometry(cloudSize, 16, 16);
    const cloudMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        cloudColor: { 
          value: new THREE.Vector3(
            0.2 + Math.random() * 0.6,
            0.2 + Math.random() * 0.4,
            0.4 + Math.random() * 0.6
          )
        }
      },
      vertexShader: `
        uniform float time;
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 cloudColor;
        void main() {
          float pulse = sin(time * 0.8) * 0.4 + 0.6;
          gl_FragColor = vec4(cloudColor, 0.03 * pulse);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending
    });
    
    // Random positioning throughout the celestial sphere
    const angle = Math.random() * Math.PI * 2;
    const inclination = Math.random() * Math.PI;
    const radius = 85 + Math.random() * 15;
    
    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
    cloud.position.set(
      Math.sin(inclination) * Math.cos(angle) * radius,
      Math.cos(inclination) * radius,
      Math.sin(inclination) * Math.sin(angle) * radius
    );
    cosmicGroup.add(cloud);
  }
  
  // Add distant galaxy representations
  for (let i = 0; i < 8; i++) {
    const galaxyGeometry = new THREE.PlaneGeometry(6, 2);
    const galaxyMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        galaxyType: { value: Math.random() }
      },
      vertexShader: `
        uniform float time;
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float galaxyType;
        void main() {
          vec2 uv = gl_FragCoord.xy;
          
          // Different galaxy types
          vec3 color = galaxyType < 0.5 ? 
            vec3(0.9, 0.8, 0.6) : // Elliptical - yellowish
            vec3(0.6, 0.7, 0.9);   // Spiral - bluish
          
          float brightness = sin(time * 1.5) * 0.2 + 0.3;
          gl_FragColor = vec4(color, 0.15 * brightness);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending
    });
    
    // Position at far distances
    const angle = Math.random() * Math.PI * 2;
    const inclination = Math.random() * Math.PI;
    const radius = 120;
    
    const galaxy = new THREE.Mesh(galaxyGeometry, galaxyMaterial);
    galaxy.position.set(
      Math.sin(inclination) * Math.cos(angle) * radius,
      Math.cos(inclination) * radius,
      Math.sin(inclination) * Math.sin(angle) * radius
    );
    galaxy.lookAt(0, 0, 0);
    cosmicGroup.add(galaxy);
  }
  
  // Clone enhanced cosmic background for sky view
  const skyCosmicGroup = cosmicGroup.clone();
  sceneSky.add(skyCosmicGroup);
  
  // ============ PROFESSIONAL CONSTELLATION VISUALIZATION ============
  const constellationGroup = new THREE.Group();
  celestialSphere.add(constellationGroup);
  
  const constellationLabels = [];
  
  // Enhanced constellation mythology data
  const mythologyInfo = {
    'Orion': { story: 'The Hunter', culture: 'Greek', season: 'Winter' },
    'Ursa Major': { story: 'Great Bear', culture: 'Greek', season: 'Spring' },
    'Cassiopeia': { story: 'The Queen', culture: 'Greek', season: 'Autumn' },
    'Leo': { story: 'The Lion', culture: 'Greek', season: 'Spring' },
    'Scorpius': { story: 'The Scorpion', culture: 'Greek', season: 'Summer' },
    'Cygnus': { story: 'The Swan', culture: 'Greek', season: 'Summer' },
    'Gemini': { story: 'The Twins', culture: 'Greek', season: 'Winter' },
    'Taurus': { story: 'The Bull', culture: 'Greek', season: 'Winter' },
    'Virgo': { story: 'The Maiden', culture: 'Greek', season: 'Summer' },
    'Sagittarius': { story: 'The Archer', culture: 'Greek', season: 'Summer' }
  };
  
  Object.entries(CONSTELLATIONS).forEach(([name, data]) => {
    const points = [];
    data.stars.forEach(([ra, dec]) => {
      const r = 99;
      const raRad = ra * DEG2RAD;
      const decRad = dec * DEG2RAD;
      points.push(new THREE.Vector3(
        r * Math.cos(decRad) * Math.cos(raRad),
        r * Math.sin(decRad),
        r * Math.cos(decRad) * Math.sin(raRad)
      ));
    });
    
    // Multi-weight constellation lines (primary vs secondary stars)
    data.lines.forEach(([i, j], index) => {
      const lineGeom = new THREE.BufferGeometry().setFromPoints([points[i], points[j]]);
      
      // Primary lines are brighter and thicker
      const isPrimaryLine = index < data.lines.length * 0.6; // First 60% are primary
      const lineMat = new THREE.LineBasicMaterial({ 
        color: isPrimaryLine ? 0x77aaff : 0x4466cc,
        opacity: isPrimaryLine ? 0.8 : 0.4,
        transparent: true,
        linewidth: isPrimaryLine ? 3 : 1.5
      });
      
      const line = new THREE.Line(lineGeom, lineMat);
      constellationGroup.add(line);
      
      // Add to sky view with same properties
      const skyLine = line.clone();
      sceneSky.add(skyLine);
    });
    
    // Create artistic constellation boundary
    if (data.stars.length > 2) {
      const boundaryPoints = [...data.stars];
      if (boundaryPoints.length > 3) {
        // Create a smooth boundary using the constellation stars
        const boundaryGeom = new THREE.BufferGeometry();
        const boundaryPositions = [];
        
        for (let i = 0; i <= boundaryPoints.length; i++) {
          const point = boundaryPoints[i % boundaryPoints.length];
          const r = 98.5;
          const raRad = point[0] * DEG2RAD;
          const decRad = point[1] * DEG2RAD;
          boundaryPositions.push(
            r * Math.cos(decRad) * Math.cos(raRad),
            r * Math.sin(decRad),
            r * Math.cos(decRad) * Math.sin(raRad)
          );
        }
        
        boundaryGeom.setAttribute('position', new THREE.Float32BufferAttribute(boundaryPositions, 3));
        const boundaryMat = new THREE.LineBasicMaterial({
          color: 0x8899ff,
          transparent: true,
          opacity: 0.25,
          linewidth: 1
        });
        
        const boundaryLine = new THREE.Line(boundaryGeom, boundaryMat);
        constellationGroup.add(boundaryLine);
        
        // Add to sky view
        const skyBoundary = boundaryLine.clone();
        sceneSky.add(skyBoundary);
      }
    }
    
    // Enhanced constellation label with artistic design
    if (data.label) {
      const labelGeom = new THREE.PlaneGeometry(12, 3);
      const canvas = document.createElement('canvas');
      canvas.width = 384;
      canvas.height = 96;
      const ctx = canvas.getContext('2d');
      
      // Create artistic background
      const gradient = ctx.createLinearGradient(0, 0, 384, 96);
      gradient.addColorStop(0, 'rgba(65, 105, 225, 0.8)');
      gradient.addColorStop(0.5, 'rgba(138, 43, 226, 0.8)');
      gradient.addColorStop(1, 'rgba(72, 61, 139, 0.8)');
      
      ctx.fillStyle = gradient;
      ctx.roundRect = function(x, y, w, h, r) {
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
      };
      
      ctx.roundRect(0, 0, 384, 96, 15);
      ctx.fill();
      
      // Add border
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Add constellation name
      ctx.fillStyle = 'white';
      ctx.font = 'bold 24px serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      ctx.shadowBlur = 4;
      ctx.fillText(name, 192, 28);
      
      // Add mythology subtitle
      const mythology = mythologyInfo[name];
      if (mythology) {
        ctx.fillStyle = 'rgba(255, 220, 150, 0.9)';
        ctx.font = '16px sans-serif';
        ctx.fillText(mythology.story, 192, 50);
        
        // Add cultural and seasonal information
        ctx.fillStyle = 'rgba(200, 200, 255, 0.7)';
        ctx.font = '12px sans-serif';
        ctx.fillText(`${mythology.culture} • ${mythology.season}`, 192, 70);
      } else {
        // Fallback for constellations without mythology info
        const constellationTypes = {
          'Taurus': 'The Bull', 'Aries': 'The Ram', 'Cancer': 'The Crab',
          'Libra': 'The Scales', 'Capricornus': 'Sea Goat', 'Pisces': 'The Fishes',
          'Aquarius': 'Water Bearer'
        };
        
        const subtitle = constellationTypes[name] || 'Constellation';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = '16px sans-serif';
        ctx.fillText(subtitle, 192, 55);
      }
      
      // Add decorative stars
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      for (let i = 0; i < 5; i++) {
        const x = 30 + i * 70;
        const y = 15;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      const labelTexture = new THREE.CanvasTexture(canvas);
      const labelMat = new THREE.MeshBasicMaterial({
        map: labelTexture,
        transparent: true,
        opacity: 0.9
      });
      
      const labelMesh = new THREE.Mesh(labelGeom, labelMat);
      const r = 103;
      const raRad = data.label.ra * DEG2RAD;
      const decRad = data.label.dec * DEG2RAD;
      
      labelMesh.position.set(
        r * Math.cos(decRad) * Math.cos(raRad),
        r * Math.sin(decRad),
        r * Math.cos(decRad) * Math.sin(raRad)
      );
      labelMesh.lookAt(0, 0, 0);
      
      constellationGroup.add(labelMesh);
      constellationLabels.push(labelMesh);
      
      // Add to sky view with simpler version
      const skyLabelGeom = new THREE.PlaneGeometry(8, 2);
      const skyLabelMat = new THREE.MeshBasicMaterial({
        map: labelTexture,
        transparent: true,
        opacity: 0.8
      });
      const skyLabel = new THREE.Mesh(skyLabelGeom, skyLabelMat);
      skyLabel.position.copy(labelMesh.position);
      skyLabel.lookAt(0, 0, 0);
      sceneSky.add(skyLabel);
    }
  });
  
  // ============ Planets ============
  const planetGroup = new THREE.Group();
  scene3d.add(planetGroup);
  
  const planetMeshes = {};
  const orbitLines = {};
  
  Object.entries(PLANETS).forEach(([name, data]) => {
    // Planet sphere
    const planetGeom = new THREE.SphereGeometry(data.size, 32, 32);
    const planetMat = new THREE.MeshPhongMaterial({ 
      color: data.color,
      emissive: data.color,
      emissiveIntensity: 0.2
    });
    const planetMesh = new THREE.Mesh(planetGeom, planetMat);
    planetMesh.castShadow = true;
    planetMesh.receiveShadow = true;
    planetGroup.add(planetMesh);
    planetMeshes[name] = planetMesh;
    
    // Orbit line
    const orbitPoints = [];
    for (let angle = 0; angle <= 360; angle += 5) {
      const rad = angle * DEG2RAD;
      orbitPoints.push(new THREE.Vector3(
        data.a * 2 * Math.cos(rad),
        0,
        data.a * 2 * Math.sin(rad)
      ));
    }
    const orbitGeom = new THREE.BufferGeometry().setFromPoints(orbitPoints);
    const orbitMat = new THREE.LineBasicMaterial({ 
      color: data.color,
      opacity: 0.2,
      transparent: true
    });
    const orbitLine = new THREE.Line(orbitGeom, orbitMat);
    planetGroup.add(orbitLine);
    orbitLines[name] = orbitLine;
  });
  
  // ============ Enhanced Sun with Spectacular Effects ============
  const sunGroup = new THREE.Group();
  scene3d.add(sunGroup);
  
  // Sun core with shader material
  const sunGeom = new THREE.SphereGeometry(0.12, 64, 64);
  const sunMat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      intensity: { value: 2.0 }
    },
    vertexShader: `
      uniform float time;
      varying vec3 vPosition;
      varying vec3 vNormal;
      void main() {
        vPosition = position;
        vNormal = normal;
        
        // Surface activity (solar flares simulation)
        vec3 pos = position;
        float activity = sin(time * 3.0 + position.x * 10.0) * 0.02 +
                        sin(time * 2.5 + position.y * 8.0) * 0.015 +
                        sin(time * 4.0 + position.z * 12.0) * 0.01;
        pos += normal * activity;
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    fragmentShader: `
      uniform float time;
      uniform float intensity;
      varying vec3 vPosition;
      varying vec3 vNormal;
      
      void main() {
        // Solar surface texture
        float surface = sin(vPosition.x * 20.0 + time * 2.0) * 
                       sin(vPosition.y * 15.0 + time * 1.5) * 
                       sin(vPosition.z * 18.0 + time * 3.0);
        
        // Color temperature variation
        vec3 hotColor = vec3(1.0, 1.0, 0.8);
        vec3 coolColor = vec3(1.0, 0.6, 0.2);
        vec3 sunColor = mix(coolColor, hotColor, surface * 0.5 + 0.5);
        
        // Brightness pulsing
        float pulse = sin(time * 4.0) * 0.2 + 0.8;
        
        gl_FragColor = vec4(sunColor * intensity * pulse, 1.0);
      }
    `
  });
  const sunMesh = new THREE.Mesh(sunGeom, sunMat);
  sunGroup.add(sunMesh);
  
  // Multi-layer corona effect
  for (let i = 0; i < 4; i++) {
    const coronaSize = 0.15 + i * 0.05;
    const coronaGeom = new THREE.SphereGeometry(coronaSize, 32, 32);
    const coronaMat = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        layer: { value: i },
        opacity: { value: 0.3 / (i + 1) }
      },
      vertexShader: `
        uniform float time;
        uniform float layer;
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float layer;
        uniform float opacity;
        void main() {
          float pulse = sin(time * (2.0 + layer * 0.5)) * 0.4 + 0.6;
          vec3 coronaColor = mix(vec3(1.0, 0.8, 0.4), vec3(1.0, 0.4, 0.1), layer / 4.0);
          gl_FragColor = vec4(coronaColor, opacity * pulse);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide
    });
    const corona = new THREE.Mesh(coronaGeom, coronaMat);
    sunGroup.add(corona);
  }
  
  // Solar flares as animated sprites
  for (let i = 0; i < 8; i++) {
    const flareGeom = new THREE.PlaneGeometry(0.4, 0.1);
    const flareMat = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        flareIndex: { value: i },
        opacity: { value: 0.6 }
      },
      vertexShader: `
        uniform float time;
        uniform float flareIndex;
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float flareIndex;
        uniform float opacity;
        void main() {
          float flareActivity = sin(time * 3.0 + flareIndex * 2.0) * 0.5 + 0.5;
          vec3 flareColor = vec3(1.0, 0.7, 0.3);
          gl_FragColor = vec4(flareColor, opacity * flareActivity);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending
    });
    
    const flare = new THREE.Mesh(flareGeom, flareMat);
    const angle = (i / 8) * Math.PI * 2;
    flare.position.set(Math.cos(angle) * 0.15, Math.sin(angle) * 0.15, 0);
    flare.rotation.z = angle;
    sunGroup.add(flare);
  }
  
  // ============ Enhanced Moon with Realistic Phases ============
  const moonGroup = new THREE.Group();
  scene3d.add(moonGroup);
  
  const moonGeom = new THREE.SphereGeometry(0.06, 64, 64);
  const moonMat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      sunDirection: { value: new THREE.Vector3(1, 0, 0) },
      earthGlow: { value: 0.1 }
    },
    vertexShader: `
      uniform float time;
      varying vec3 vPosition;
      varying vec3 vNormal;
      void main() {
        vPosition = position;
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float time;
      uniform vec3 sunDirection;
      uniform float earthGlow;
      varying vec3 vPosition;
      varying vec3 vNormal;
      
      // Lunar surface texture
      float lunarNoise(vec3 p) {
        return fract(sin(dot(p, vec3(127.1, 311.7, 543.5))) * 43758.5453);
      }
      
      void main() {
        vec3 normal = normalize(vNormal);
        float sunDot = max(0.0, dot(normal, normalize(sunDirection)));
        
        // Lunar surface detail
        float craters = lunarNoise(vPosition * 20.0) * lunarNoise(vPosition * 40.0);
        vec3 lunarColor = vec3(0.8, 0.8, 0.7) + craters * 0.2;
        
        // Sunlit and shadowed areas
        vec3 litColor = lunarColor * sunDot;
        vec3 shadowColor = lunarColor * earthGlow; // Earthshine
        
        vec3 finalColor = mix(shadowColor, litColor, sunDot);
        
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `
  });
  const moonMesh = new THREE.Mesh(moonGeom, moonMat);
  moonGroup.add(moonMesh);
  
  // Subtle moon glow
  const moonGlowGeom = new THREE.SphereGeometry(0.08, 32, 32);
  const moonGlowMat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      opacity: { value: 0.15 }
    },
    vertexShader: `
      uniform float time;
      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float time;
      uniform float opacity;
      void main() {
        float glow = sin(time * 2.0) * 0.3 + 0.7;
        gl_FragColor = vec4(0.9, 0.9, 0.8, opacity * glow);
      }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    side: THREE.BackSide
  });
  const moonGlow = new THREE.Mesh(moonGlowGeom, moonGlowMat);
  moonGroup.add(moonGlow);
  
  // ============ Lens Flare System ============
  const lensFlareGroup = new THREE.Group();
  scene3d.add(lensFlareGroup);
  
  // Create lens flare elements for the Sun
  for (let i = 0; i < 6; i++) {
    const flareGeom = new THREE.RingGeometry(0.1 + i * 0.15, 0.15 + i * 0.15, 16);
    const flareMat = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        flareIndex: { value: i },
        intensity: { value: 0.3 / (i + 1) }
      },
      vertexShader: `
        uniform float time;
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float flareIndex;
        uniform float intensity;
        void main() {
          float flicker = sin(time * 5.0 + flareIndex * 3.14159) * 0.5 + 0.5;
          vec3 flareColor = mix(vec3(1.0, 0.8, 0.4), vec3(0.8, 0.4, 1.0), flareIndex / 6.0);
          gl_FragColor = vec4(flareColor, intensity * flicker);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide
    });
    
    const lensFlare = new THREE.Mesh(flareGeom, flareMat);
    lensFlareGroup.add(lensFlare);
  }
  
  // ============ Celestial Grid ============
  const gridGroup = new THREE.Group();
  celestialSphere.add(gridGroup);
  
  // RA lines
  for (let ra = 0; ra < 360; ra += 15) {
    const points = [];
    for (let dec = -90; dec <= 90; dec += 5) {
      const r = 98;
      const raRad = ra * DEG2RAD;
      const decRad = dec * DEG2RAD;
      points.push(new THREE.Vector3(
        r * Math.cos(decRad) * Math.cos(raRad),
        r * Math.sin(decRad),
        r * Math.cos(decRad) * Math.sin(raRad)
      ));
    }
    const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
    const lineMat = new THREE.LineBasicMaterial({ 
      color: 0x333366,
      opacity: 0.2,
      transparent: true
    });
    gridGroup.add(new THREE.Line(lineGeom, lineMat));
  }
  
  // Dec lines
  for (let dec = -60; dec <= 60; dec += 30) {
    const points = [];
    for (let ra = 0; ra <= 360; ra += 5) {
      const r = 98;
      const raRad = ra * DEG2RAD;
      const decRad = dec * DEG2RAD;
      points.push(new THREE.Vector3(
        r * Math.cos(decRad) * Math.cos(raRad),
        r * Math.sin(decRad),
        r * Math.cos(decRad) * Math.sin(raRad)
      ));
    }
    const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
    const lineMat = new THREE.LineBasicMaterial({ 
      color: 0x333366,
      opacity: 0.2,
      transparent: true
    });
    gridGroup.add(new THREE.Line(lineGeom, lineMat));
  }
  
  // ============ Observer ============
  const observerGeom = new THREE.ConeGeometry(0.05, 0.15, 8);
  const observerMat = new THREE.MeshPhongMaterial({ 
    color: 0xff3333,
    emissive: 0xff3333,
    emissiveIntensity: 0.5
  });
  const observer = new THREE.Mesh(observerGeom, observerMat);
  observer.castShadow = true;
  scene3d.add(observer);
  
  // ============ UI Controls ============
  const $ = id => document.getElementById(id);
  
  const latInput = $('lat');
  const lonInput = $('lon');
  const altInput = $('alt');
  const timeInput = $('time');
  
  function setCurrentTime() {
    const now = new Date();
    const iso = now.toISOString().slice(0, 19);
    timeInput.value = iso;
  }
  
  $('btnNow').addEventListener('click', setCurrentTime);
  setCurrentTime();
  
  $('btnGeo').addEventListener('click', () => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(pos => {
        latInput.value = pos.coords.latitude.toFixed(4);
        lonInput.value = pos.coords.longitude.toFixed(4);
        altInput.value = Math.round(pos.coords.altitude || 10);
        showToast("Location updated successfully");
      }, error => {
        showToast("Unable to get your location", 4000);
        console.error("Geolocation error:", error);
      });
    } else {
      showToast("Geolocation is not supported by this browser", 4000);
    }
  });
  
  let animating = false;
  let animSpeed = 60;
  
  $('btnAnimate').addEventListener('click', () => {
    animating = true;
    $('btnAnimate').disabled = true;
    $('btnPause').disabled = false;
    showToast("Animation started");
  });
  
  $('btnPause').addEventListener('click', () => {
    animating = false;
    $('btnAnimate').disabled = false;
    $('btnPause').disabled = true;
    showToast("Animation paused");
  });
  
  // Animation speed control
  const animSpeedSlider = $('animSpeed');
  const speedValueDisplay = $('speedValue');
  
  animSpeedSlider.addEventListener('input', (e) => {
    animSpeed = parseInt(e.target.value);
    
    // Update display
    if (animSpeed < 60) {
      speedValueDisplay.textContent = `${animSpeed}s`;
    } else if (animSpeed < 3600) {
      const minutes = Math.floor(animSpeed / 60);
      speedValueDisplay.textContent = `${minutes}m`;
    } else {
      const hours = Math.floor(animSpeed / 3600);
      speedValueDisplay.textContent = `${hours}h`;
    }
  });
  
  // View mode handling
  $('viewMode').addEventListener('change', (e) => {
    const mode = e.target.value;
    const app = $('app');
    
    // Remove existing view mode classes
    app.classList.remove('view-mode-split', 'view-mode-globe', 'view-mode-sky');
    
    // Add new view mode class
    app.classList.add(`view-mode-${mode}`);
    
    // Trigger resize to adjust canvas dimensions
    setTimeout(() => {
      onResize();
    }, 100);
    
    showToast(`Switched to ${mode} view`);
  });
  
  // Screenshot functionality
  $('btnScreenshot').addEventListener('click', () => {
    try {
      const link = document.createElement('a');
      const viewMode = $('viewMode').value;
      
      if (viewMode === 'globe' || viewMode === 'split') {
        link.download = `celestial-globe-${Date.now()}.png`;
        link.href = renderer3d.domElement.toDataURL();
      } else {
        link.download = `celestial-sky-${Date.now()}.png`;
        link.href = rendererSky.domElement.toDataURL();
      }
      
      link.click();
      showToast("Screenshot saved");
    } catch (error) {
      console.error("Error taking screenshot:", error);
      showToast("Failed to take screenshot", 3000);
    }
  });
  
  // Info panel
  $('btnInfo').addEventListener('click', () => {
    $('infoPanel').classList.add('show');
  });
  
  $('closeInfo').addEventListener('click', () => {
    $('infoPanel').classList.remove('show');
  });
  
  // Reset view
  $('btnReset').addEventListener('click', () => {
    controls3d.reset();
    controlsSky.reset();
    showToast("View reset to default");
  });
  
  // ============ Graphs ============
  function drawSolarAltitudeGraph() {
    try {
      const canvas = $('graphSolar');
      const ctx = canvas.getContext('2d');
      const width = canvas.width = canvas.offsetWidth * 2;
      const height = canvas.height = canvas.offsetHeight * 2;
      
      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = '#667eea';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      const lat = parseFloat(latInput.value) || 0;
      const lon = parseFloat(lonInput.value) || 0;
      const date = new Date(timeInput.value + 'Z');
      
      for (let hour = 0; hour <= 24; hour += 0.5) {
        const testDate = new Date(date);
        testDate.setUTCHours(testDate.getUTCHours() + hour);
        const jd = toJulianDay(testDate);
        const sun = solarPosition(jd);
        const lst = localSiderealTime(jd, lon);
        const altAz = raDecToAltAz(sun.ra, sun.dec, lat, lon, lst);
        
        const x = (hour / 24) * width;
        const y = height - ((altAz.altitude + 90) / 180) * height;
        
        if (hour === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      
      ctx.stroke();
      
      // Horizon line
      ctx.strokeStyle = '#ff6666';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, height/2);
      ctx.lineTo(width, height/2);
      ctx.stroke();
    } catch (error) {
      console.error("Error drawing solar altitude graph:", error);
    }
  }
  
  function drawAnalemma() {
    try {
      const canvas = $('graphAnalemma');
      const ctx = canvas.getContext('2d');
      const width = canvas.width = canvas.offsetWidth * 2;
      const height = canvas.height = canvas.offsetHeight * 2;
      
      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = '#f093fb';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let day = 0; day < 365; day += 5) {
        const date = new Date(Date.UTC(2024, 0, 1, 12, 0, 0));
        date.setUTCDate(date.getUTCDate() + day);
        const jd = toJulianDay(date);
        const sun = solarPosition(jd);
        
        const x = width/2 + (sun.dec / 30) * width;
        const y = height/2 - ((sun.ra - 180) / 60) * height;
        
        if (day === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      
      ctx.closePath();
      ctx.stroke();
    } catch (error) {
      console.error("Error drawing analemma:", error);
    }
  }
  
  function drawPlanetPositions() {
    try {
      const canvas = $('graphPlanets');
      const ctx = canvas.getContext('2d');
      const width = canvas.width = canvas.offsetWidth * 2;
      const height = canvas.height = canvas.offsetHeight * 2;
      
      ctx.clearRect(0, 0, width, height);
      
      const date = new Date(timeInput.value + 'Z');
      const jd = toJulianDay(date);
      
      let i = 0;
      Object.entries(PLANETS).forEach(([name, data]) => {
        const pos = planetPosition(name, jd);
        const x = (pos.ra / 360) * width;
        const y = height/2 - (pos.dec / 90) * height/2;
        
        ctx.fillStyle = `#${data.color.toString(16).padStart(6, '0')}`;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, TAU);
        ctx.fill();
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px monospace';
        ctx.fillText(data.symbol, x + 6, y + 4);
        i++;
      });
    } catch (error) {
      console.error("Error drawing planet positions:", error);
    }
  }
  
  // ============ Update Function ============
  let lastUpdateTime = 0;
  const updateInterval = 100; // Update every 100ms for better performance
  
  function update() {
    const now = Date.now();
    if (now - lastUpdateTime < updateInterval) return;
    lastUpdateTime = now;
    
    try {
      const lat = parseFloat(latInput.value) || 0;
      const lon = parseFloat(lonInput.value) || 0;
      const alt = parseFloat(altInput.value) || 0;
      
      const dateStr = timeInput.value;
      const date = dateStr ? new Date(dateStr + 'Z') : new Date();
      const jd = toJulianDay(date);
      
      // Time displays
      const gmst = greenwichMeanSiderealTime(jd);
      const lst = localSiderealTime(jd, lon);
      
      $('jd').textContent = jd.toFixed(2);
      $('gmst').textContent = (gmst / 15).toFixed(2) + 'h';
      $('lst').textContent = (lst / 15).toFixed(2) + 'h';
      
      // Solar position
      const sun = solarPosition(jd);
      const sunAltAz = raDecToAltAz(sun.ra, sun.dec, lat, lon, lst);
      $('sunPos').textContent = `${sunAltAz.azimuth.toFixed(0)}°/${sunAltAz.altitude.toFixed(0)}°`;
      
      // Lunar position
      const moon = lunarPosition(jd);
      const moonAltAz = raDecToAltAz(moon.ra, moon.dec, lat, lon, lst);
      $('moonPos').textContent = `${moonAltAz.azimuth.toFixed(0)}°/${moonAltAz.altitude.toFixed(0)}°`;
      
      // Update planets
      let planetHTML = '';
      Object.entries(PLANETS).forEach(([name, data]) => {
        const pos = planetPosition(name, jd);
        const altAz = raDecToAltAz(pos.ra, pos.dec, lat, lon, lst);
        planetHTML += `<div>${data.symbol} ${name}: Az ${altAz.azimuth.toFixed(0)}° Alt ${altAz.altitude.toFixed(0)}°</div>`;
        
        // Update 3D position
        if (planetMeshes[name]) {
          const r = 2 + data.a * 0.3;
          const angle = (jd - J2000) * 360 / (data.a ** 1.5 * 365.25);
          planetMeshes[name].position.set(
            r * Math.cos(angle * DEG2RAD),
            0,
            r * Math.sin(angle * DEG2RAD)
          );
        }
      });
      $('planetList').innerHTML = planetHTML;
      
      // Update navigation stars
      let starHTML = '';
      const visibleStars = FAMOUS_STARS
        .filter(star => star.category === 'navigation' || star.category === 'famous')
        .slice(0, 8);
      
      visibleStars.forEach(star => {
        const altAz = raDecToAltAz(star.ra, star.dec, lat, lon, lst);
        if (altAz.altitude > 5) { // Only show stars above 5° altitude
          const brightness = star.mag < 1 ? '⭐' : star.mag < 2 ? '✦' : '✧';
          starHTML += `<div>${brightness} ${star.name} (${star.constellation}): Az ${altAz.azimuth.toFixed(0)}° Alt ${altAz.altitude.toFixed(0)}°</div>`;
        }
      });
      $('navStars').innerHTML = starHTML || '<div style="opacity:0.5">No prominent stars visible</div>';
      
      // Update 3D scene
      earth.rotation.y = (gmst - 90) * DEG2RAD;
      atmosphere.rotation.y = earth.rotation.y;
      celestialSphere.rotation.y = -lst * DEG2RAD;
      
      // Position observer
      const obsLat = lat * DEG2RAD;
      const obsLon = lon * DEG2RAD;
      observer.position.set(
        Math.cos(obsLat) * Math.cos(obsLon) * 1.05,
        Math.sin(obsLat) * 1.05,
        Math.cos(obsLat) * Math.sin(obsLon) * 1.05
      );
      observer.lookAt(0, 0, 0);
      
      // Position Enhanced Sun
      const sunDist = 20;
      const sunPos = new THREE.Vector3(
        sunDist * Math.cos(sun.dec * DEG2RAD) * Math.cos(sun.ra * DEG2RAD),
        sunDist * Math.sin(sun.dec * DEG2RAD),
        sunDist * Math.cos(sun.dec * DEG2RAD) * Math.sin(sun.ra * DEG2RAD)
      );
      sunGroup.position.copy(sunPos);
      sunLight.position.copy(sunPos);
      sunScatter.position.copy(sunPos);
      
      // Update sun direction for realistic directional lighting
      const sunDirection = sunPos.clone().normalize();
      sunLight.target.position.set(0, 0, 0);
      sunScatter.target.position.set(0, 0, 0);
      
      // Update sun effects
      sunGroup.children.forEach(child => {
        if (child.material && child.material.uniforms && child.material.uniforms.time) {
          child.material.uniforms.time.value = now * 0.001;
        }
      });
      
      // Enhanced atmospheric lighting updates
      atmosphericRim.position.copy(sunPos.clone().multiplyScalar(0.05)); // Subtle atmospheric rim
      
      // Dynamic earthshine intensity based on Earth's illumination
      const sunEarthDot = sunDirection.dot(new THREE.Vector3(0, 0, 0).sub(sunPos).normalize());
      earthshine.intensity = Math.max(0.1, 0.3 * (1 + sunEarthDot) * 0.5);
      
      // Update Earth texture with day/night terminator
      const sunLon = sun.ra - gmst;
      earthTexture = createUltraRealisticEarthTexture(sunLon);
      earth.material.map = earthTexture;
      earth.material.needsUpdate = true;
      
      // Position Enhanced Moon
      const moonDist = 15;
      const moonPos = new THREE.Vector3(
        moonDist * Math.cos(moon.dec * DEG2RAD) * Math.cos(moon.ra * DEG2RAD),
        moonDist * Math.sin(moon.dec * DEG2RAD),
        moonDist * Math.cos(moon.dec * DEG2RAD) * Math.sin(moon.ra * DEG2RAD)
      );
      moonGroup.position.copy(moonPos);
      moonLight.position.copy(moonPos);
      
      // Update moon direction for realistic directional lighting
      const moonDirection = moonPos.clone().normalize();
      moonLight.target.position.set(0, 0, 0);
      
      // Dynamic moon light intensity based on lunar phase
      const sunMoonAngle = sunPos.angleTo(moonPos);
      const phaseIllumination = (1 - Math.cos(sunMoonAngle)) * 0.5;
      moonLight.intensity = 0.12 * phaseIllumination; // Fade moonlight during new moon
      
      // Update moon effects and phase
      const sunToMoon = sunPos.clone().sub(moonPos).normalize();
      moonGroup.children.forEach(child => {
        if (child.material && child.material.uniforms) {
          if (child.material.uniforms.time) child.material.uniforms.time.value = now * 0.001;
          if (child.material.uniforms.sunDirection) child.material.uniforms.sunDirection.value = sunToMoon;
        }
      });
      
      // Update sky view rotation
      sceneSky.rotation.y = -lst * DEG2RAD;
      sceneSky.rotation.x = -lat * DEG2RAD;
      
      // Update atmospheric effects
      const time = now * 0.001;
      atmosphereMaterial.uniforms.time.value = time;
      
      // Update sun direction for atmosphere
      const sunDir = sunMesh.position.clone().normalize();
      atmosphereMaterial.uniforms.sunDirection.value = sunDir;
      
      // Update star scintillation
      famousStarMeshes.forEach(starMesh => {
        if (starMesh.material.uniforms) {
          starMesh.material.uniforms.time.value = time;
          
          // Update diffraction spikes
          starMesh.children.forEach(child => {
            if (child.material && child.material.uniforms && child.material.uniforms.time) {
              child.material.uniforms.time.value = time;
            }
          });
        }
      });
      
      // Toggle visibility
      starsPoints.visible = $('showStars').checked;
      constellationGroup.visible = $('showConst').checked;
      planetGroup.visible = $('showPlanets').checked;
      gridGroup.visible = $('showGrid').checked;
      
      // Update cosmic background effects
      cosmicGroup.children.forEach(child => {
        if (child.material && child.material.uniforms && child.material.uniforms.time) {
          child.material.uniforms.time.value = time;
        }
      });
      
      // Update constellation effects
      constellationGroup.children.forEach(child => {
        if (child.material && child.material.uniforms) {
          if (child.material.uniforms.time) {
            child.material.uniforms.time.value = time;
          }
        }
      });
      
      // Show/hide constellation labels  
      constellationLabels.forEach(label => {
        label.visible = $('showLabels').checked && $('showConst').checked;
        if (label.material && label.material.uniforms && label.material.uniforms.time) {
          label.material.uniforms.time.value = time;
        }
      });
      
      Object.values(orbitLines).forEach(line => {
        line.visible = $('showOrbits').checked;
      });
      
      // Update graphs
      drawSolarAltitudeGraph();
      drawAnalemma();
      drawPlanetPositions();
      
      // Animate time
      if (animating) {
        const newDate = new Date(date.getTime() + animSpeed * 1000);
        timeInput.value = newDate.toISOString().slice(0, 19);
      }
    } catch (error) {
      console.error("Error in update function:", error);
    }
  }
  
  // ============ OPTIMIZED RENDER LOOP ============
  function animate() {
    requestAnimationFrame(animate);
    
    // Performance monitoring for adaptive LOD
    updatePerformanceMetrics();
    
    update();
    controls3d.update();
    controlsSky.update();
    
    // Manual shadow map updates for performance (only when needed)
    const needsShadowUpdate = frameCount % 30 === 0; // Update shadows every 30 frames
    if (renderer3d.shadowMap.enabled && needsShadowUpdate) {
      renderer3d.shadowMap.needsUpdate = true;
    }
    
    // Optimized clearing and rendering
    renderer3d.autoClear = false;
    renderer3d.clear(true, true, true);
    renderer3d.render(scene3d, camera3d);
    
    // Sky view with simplified rendering
    rendererSky.render(sceneSky, cameraSky);
    
    // Reset shadow update flag
    if (needsShadowUpdate) {
      renderer3d.shadowMap.needsUpdate = false;
    }
  }
  
  // ============ Window Resize ============
  function onResize() {
    try {
      const width3d = canvas3d.clientWidth;
      const height3d = canvas3d.clientHeight;
      
      camera3d.aspect = width3d / height3d;
      camera3d.updateProjectionMatrix();
      renderer3d.setSize(width3d, height3d);
      
      const widthSky = canvasSky.clientWidth;
      const heightSky = canvasSky.clientHeight;
      
      cameraSky.aspect = widthSky / heightSky;
      cameraSky.updateProjectionMatrix();
      rendererSky.setSize(widthSky, heightSky);
      
      // Redraw graphs after resize
      setTimeout(() => {
        drawSolarAltitudeGraph();
        drawAnalemma();
        drawPlanetPositions();
      }, 100);
    } catch (error) {
      console.error("Error during resize:", error);
    }
  }
  
  window.addEventListener('resize', onResize);
  onResize();
  
  // Add legends
  const legend3d = document.createElement('div');
  legend3d.id = 'legend';
  legend3d.innerHTML = `
    <strong>3D Celestial Globe</strong><br>
    🌍 Earth with day/night cycle<br>
    ⭐ Famous stars & 30+ constellations<br>
    🌌 Milky Way representation<br>
    🪐 All planets with orbits<br>
    ☀️ Sun & 🌙 Moon positions<br>
    📍 Observer location marker
  `;
  canvas3d.appendChild(legend3d);
  
  const legendSky = document.createElement('div');
  legendSky.id = 'legend';
  legendSky.innerHTML = `
    <strong>Observer's Sky View</strong><br>
    View from your location<br>
    Shows visible famous stars<br>
    Constellation patterns & labels<br>
    🌌 Milky Way band<br>
    <em>Drag to look around the sky</em>
  `;
  canvasSky.appendChild(legendSky);
  
  // Initialize view mode
  $('app').classList.add('view-mode-split');
  
  // Start
  setTimeout(() => {
    $('loading').style.display = 'none';
    $('app').style.display = 'grid';
    animate();
  }, 1000);
  
})();
</script>
</body>
</html>
